<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è„Šæ¤çµ‚æ¿æ¨™è¨»å·¥å…· - Spine Endplate Annotation</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 0;
            min-height: calc(100vh - 200px);
        }
        
        .image-section {
            padding: 20px;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .btn-primary { background: #667eea; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        
        .canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: auto;
        }
        
        canvas {
            max-width: 100%;
            max-height: 100%;
            cursor: crosshair;
            border: 2px solid #dee2e6;
            border-radius: 4px;
        }
        
        .sidebar {
            background: white;
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #e9ecef;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: #495057;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }
        
        .measurement-card {
            background: #f8f9fa;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }
        
        .measurement-card.warning {
            border-left-color: #ffc107;
            background: #fff3cd;
        }
        
        .measurement-card.danger {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        
        .level-label {
            font-weight: bold;
            color: #667eea;
            font-size: 15px;
            margin-bottom: 6px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 13px;
        }
        
        .metric-label {
            color: #6c757d;
        }
        
        .metric-value {
            font-weight: 500;
            color: #212529;
        }
        
        .slider-group {
            margin: 10px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #495057;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
        }
        
        .progress-info {
            background: #e7f3ff;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #007bff;
        }
        
        .progress-info strong {
            color: #007bff;
        }
        
        .export-section {
            background: #d4edda;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #c3e6cb;
        }
        
        .export-section button {
            width: 100%;
            margin-top: 10px;
        }
        
        .alert {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        
        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                border-left: none;
                border-top: 2px solid #e9ecef;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¥ è„Šæ¤çµ‚æ¿æ¨™è¨»å·¥å…·</h1>
            <p>Spine Endplate Annotation Tool - ç”¨æ–¼æ”¶é›†è¨“ç·´æ•¸æ“š</p>
        </div>
        
        <div class="main-content">
            <!-- å·¦å´ï¼šå½±åƒå€åŸŸ -->
            <div class="image-section">
                <div class="controls">
                    <button class="btn-primary" onclick="pasteImage()">ğŸ“‹ è²¼ä¸Šå½±åƒ (Ctrl+V)</button>
                    <button class="btn-success" onclick="toggleEdgeDetection()">ğŸ” é‚Šç·£æª¢æ¸¬</button>
                    <button class="btn-warning" onclick="undoLastPoint()">â†¶ æ’¤éŠ·</button>
                    <button class="btn-danger" onclick="clearAll()">ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨</button>
                </div>
                
                <div class="slider-group">
                    <label>é‚Šç·£æª¢æ¸¬é–¾å€¼: <span id="thresholdValue">30</span></label>
                    <input type="range" id="edgeThreshold" min="10" max="100" value="30" 
                           oninput="updateThreshold(this.value)">
                </div>
                
                <div class="canvas-wrapper">
                    <canvas id="mainCanvas"></canvas>
                </div>
            </div>
            
            <!-- å³å´ï¼šåˆ†æçµæœ -->
            <div class="sidebar">
                <div class="alert alert-info">
                    <strong>ğŸ“ ä½¿ç”¨èªªæ˜ï¼š</strong><br>
                    1. æŒ‰ Ctrl+V è²¼ä¸Šè„Šæ¤Xå…‰å½±åƒ<br>
                    2. ä¾åºé»æ“Šæ¯å€‹æ¤é–“éš™çš„çµ‚æ¿ï¼ˆæ¯å€‹4é»ï¼‰<br>
                    3. é»æ“Šé †åºï¼šä¸‹çµ‚æ¿2é» â†’ ä¸Šçµ‚æ¿2é»<br>
                    4. å®Œæˆå¾Œé»æ“Šã€ŒåŒ¯å‡ºè¨“ç·´æ•¸æ“šã€
                </div>
                
                <div class="progress-info">
                    <strong>æ¨™è¨»é€²åº¦ï¼š</strong><span id="progressText">å°šæœªé–‹å§‹</span>
                </div>
                
                <div class="section">
                    <div class="section-title">ğŸ“Š æ¤é–“éš™åˆ†æ</div>
                    <div id="measurementsList"></div>
                </div>
                
                <div class="section">
                    <div class="section-title">âš ï¸ ç•°å¸¸æª¢æ¸¬</div>
                    <div id="abnormalitiesList"></div>
                </div>
                
                <div class="export-section">
                    <strong>ğŸ’¾ åŒ¯å‡ºè¨“ç·´æ•¸æ“š</strong>
                    <button class="btn-success" onclick="exportTrainingData()">
                        åŒ¯å‡º JSON + å½±åƒ
                    </button>
                    <button class="btn-secondary" onclick="copyResults()">
                        è¤‡è£½çµæœåˆ°å‰ªè²¼ç°¿
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€è®Šæ•¸ ====================
        let canvas, ctx;
        let originalImage = null;
        let edgeImage = null;
        let showEdge = false;
        let currentPoints = [];
        let vertebrae = [];
        let edgeThreshold = 30;
        
        // ==================== åˆå§‹åŒ– ====================
        window.onload = function() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            
            // ç›£è½è²¼ä¸Šäº‹ä»¶
            document.addEventListener('paste', handlePaste);
            canvas.addEventListener('click', handleCanvasClick);
        };
        
        // ==================== å½±åƒè™•ç† ====================
        function handlePaste(e) {
            e.preventDefault();
            const items = e.clipboardData.items;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    loadImageFromBlob(blob);
                    return;
                }
            }
            alert('âŒ å‰ªè²¼ç°¿ä¸­æ²’æœ‰åœ–ç‰‡ï¼è«‹å…ˆè¤‡è£½å½±åƒã€‚');
        }
        
        function pasteImage() {
            navigator.clipboard.read().then(data => {
                for (let i = 0; i < data.length; i++) {
                    if (data[i].types.includes('image/png') || data[i].types.includes('image/jpeg')) {
                        data[i].getType('image/png').then(blob => {
                            loadImageFromBlob(blob);
                        });
                        return;
                    }
                }
                alert('âŒ è«‹å…ˆè¤‡è£½åœ–ç‰‡åˆ°å‰ªè²¼ç°¿ï¼');
            }).catch(() => {
                alert('âŒ è«‹ä½¿ç”¨ Ctrl+V è²¼ä¸Šåœ–ç‰‡ï¼Œæˆ–å…ˆè¤‡è£½åœ–ç‰‡ã€‚');
            });
        }
        
        function loadImageFromBlob(blob) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    if (showEdge) {
                        applyEdgeDetection();
                    }
                    redraw();
                    updateProgress();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
        }
        
        // ==================== é‚Šç·£æª¢æ¸¬ ====================
        function toggleEdgeDetection() {
            showEdge = !showEdge;
            if (showEdge && originalImage) {
                applyEdgeDetection();
            }
            redraw();
        }
        
        function updateThreshold(value) {
            edgeThreshold = parseInt(value);
            document.getElementById('thresholdValue').textContent = value;
            if (showEdge && originalImage) {
                applyEdgeDetection();
            }
        }
        
        function applyEdgeDetection() {
            if (!originalImage) return;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = originalImage.width;
            tempCanvas.height = originalImage.height;
            
            tempCtx.drawImage(originalImage, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // è½‰ç°éš
            const grayData = new Uint8ClampedArray(tempCanvas.width * tempCanvas.height);
            for (let i = 0; i < data.length; i += 4) {
                grayData[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            
            // Sobel é‚Šç·£æª¢æ¸¬
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            const edgeData = new Uint8ClampedArray(tempCanvas.width * tempCanvas.height);
            
            for (let y = 1; y < tempCanvas.height - 1; y++) {
                for (let x = 1; x < tempCanvas.width - 1; x++) {
                    let gx = 0, gy = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = (y + ky) * tempCanvas.width + (x + kx);
                            const gray = grayData[idx];
                            const sobelIdx = (ky + 1) * 3 + (kx + 1);
                            gx += gray * sobelX[sobelIdx];
                            gy += gray * sobelY[sobelIdx];
                        }
                    }
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const idx = y * tempCanvas.width + x;
                    edgeData[idx] = magnitude > edgeThreshold ? 255 : 0;
                }
            }
            
            // å‰µå»ºé‚Šç·£å½±åƒ
            const resultCanvas = document.createElement('canvas');
            const resultCtx = resultCanvas.getContext('2d');
            resultCanvas.width = tempCanvas.width;
            resultCanvas.height = tempCanvas.height;
            
            resultCtx.globalAlpha = 0.6;
            resultCtx.drawImage(originalImage, 0, 0);
            resultCtx.globalAlpha = 1.0;
            
            const resultImageData = resultCtx.getImageData(0, 0, resultCanvas.width, resultCanvas.height);
            const resultData = resultImageData.data;
            
            for (let i = 0; i < edgeData.length; i++) {
                if (edgeData[i] > 0) {
                    const pixelIndex = i * 4;
                    resultData[pixelIndex] = 0;
                    resultData[pixelIndex + 1] = 255;
                    resultData[pixelIndex + 2] = 0;
                    resultData[pixelIndex + 3] = 255;
                }
            }
            
            resultCtx.putImageData(resultImageData, 0, 0);
            
            edgeImage = new Image();
            edgeImage.src = resultCanvas.toDataURL();
            edgeImage.onload = () => redraw();
        }
        
        // ==================== é»æ“Šè™•ç† ====================
        function handleCanvasClick(event) {
            if (!originalImage) {
                alert('âŒ è«‹å…ˆè²¼ä¸Šå½±åƒï¼');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            currentPoints.push({x, y});
            
            if (currentPoints.length === 4) {
                // å®Œæˆä¸€å€‹æ¤é–“éš™
                const level = `L${5 - vertebrae.length}/L${6 - vertebrae.length}`;
                if (vertebrae.length >= 5) {
                    level = `L${6 - vertebrae.length}/S1`;
                }
                
                vertebrae.push({
                    level: level,
                    lowerEndplate: [currentPoints[0], currentPoints[1]],
                    upperEndplate: [currentPoints[2], currentPoints[3]]
                });
                
                currentPoints = [];
                updateAnalysis();
            }
            
            redraw();
            updateProgress();
        }
        
        // ==================== ç¹ªè£½ ====================
        function redraw() {
            if (!originalImage) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½å½±åƒ
            if (showEdge && edgeImage) {
                ctx.drawImage(edgeImage, 0, 0);
            } else {
                ctx.drawImage(originalImage, 0, 0);
            }
            
            // ç¹ªè£½å·²å®Œæˆçš„æ¤é–“éš™
            vertebrae.forEach((v, idx) => {
                // ä¸‹çµ‚æ¿ï¼ˆç´…ç·šï¼‰
                drawLine(v.lowerEndplate[0], v.lowerEndplate[1], '#ff0000', 3);
                // ä¸Šçµ‚æ¿ï¼ˆè—ç·šï¼‰
                drawLine(v.upperEndplate[0], v.upperEndplate[1], '#0000ff', 3);
                
                // æ¨™ç±¤
                const centerX = (v.lowerEndplate[0].x + v.upperEndplate[1].x) / 2;
                const centerY = (v.lowerEndplate[0].y + v.upperEndplate[0].y) / 2;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 20px Arial';
                const textWidth = ctx.measureText(v.level).width;
                ctx.fillRect(centerX - textWidth/2 - 10, centerY - 15, textWidth + 20, 30);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - textWidth/2 - 10, centerY - 15, textWidth + 20, 30);
                
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(v.level, centerX, centerY);
            });
            
            // ç¹ªè£½ç•¶å‰é»
            currentPoints.forEach((p, idx) => {
                const color = idx < 2 ? '#ff0000' : '#0000ff';
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // é»åºè™Ÿ
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((idx + 1).toString(), p.x, p.y);
            });
        }
        
        function drawLine(p1, p2, color, width) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
        
        // ==================== åˆ†æè¨ˆç®— ====================
        function calculateAngle(p1, p2, p3, p4) {
            const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const angle2 = Math.atan2(p4.y - p3.y, p4.x - p3.x);
            let diff = Math.abs(angle1 - angle2) * 180 / Math.PI;
            if (diff > 90) diff = 180 - diff;
            return diff;
        }
        
        function calculateDiscHeight(lowerEndplate, upperEndplate) {
            // è¨ˆç®—æ¤é–“ç›¤é«˜åº¦ï¼ˆå‰ã€ä¸­ã€å¾Œï¼‰
            const anterior = Math.abs(upperEndplate[0].y - lowerEndplate[0].y);
            const posterior = Math.abs(upperEndplate[1].y - lowerEndplate[1].y);
            const middle = (anterior + posterior) / 2;
            return {anterior, middle, posterior};
        }
        
        function detectListhesis(vertebrae) {
            // æª¢æ¸¬æ»‘è„«
            const results = [];
            for (let i = 0; i < vertebrae.length - 1; i++) {
                const current = vertebrae[i];
                const next = vertebrae[i + 1];
                
                // æ¯”è¼ƒå¾Œç·£ä½ç½®
                const currentPost = current.lowerEndplate[1].x;
                const nextPost = next.upperEndplate[1].x;
                const shift = currentPost - nextPost;
                
                // è¨ˆç®—æ¤é«”å¯¬åº¦ä½œç‚ºåƒè€ƒ
                const width = Math.abs(current.lowerEndplate[1].x - current.lowerEndplate[0].x);
                const shiftPercent = (shift / width) * 100;
                
                if (Math.abs(shiftPercent) > 5) {
                    results.push({
                        level: `${current.level} â†’ ${next.level}`,
                        type: shift > 0 ? 'Anterolisthesis' : 'Retrolisthesis',
                        shift: Math.abs(shiftPercent).toFixed(1) + '%'
                    });
                }
            }
            return results;
        }
        
        function detectDiscNarrowing(vertebrae) {
            // æª¢æ¸¬æ¤é–“ç›¤ç‹¹çª„
            const results = [];
            const heights = [];
            
            vertebrae.forEach(v => {
                const h = calculateDiscHeight(v.lowerEndplate, v.upperEndplate);
                heights.push({level: v.level, height: h.middle});
            });
            
            // L4/5 æ‡‰è©²æœ€é«˜
            if (heights.length >= 4) {
                const l45Index = heights.findIndex(h => h.level.includes('L4/L5'));
                if (l45Index >= 0) {
                    const l45Height = heights[l45Index].height;
                    
                    heights.forEach((h, idx) => {
                        if (idx !== l45Index && idx < l45Index) {
                            if (h.height > l45Height * 1.1) {
                                results.push({
                                    level: h.level,
                                    issue: 'æ¤é–“ç›¤é«˜åº¦ç•°å¸¸ï¼ˆé«˜æ–¼L4/5ï¼‰'
                                });
                            }
                        }
                    });
                }
            }
            
            // æª¢æŸ¥ç›¸é„°é«˜åº¦å·®ç•°
            for (let i = 0; i < heights.length - 1; i++) {
                const ratio = heights[i].height / heights[i + 1].height;
                if (ratio < 0.6 || ratio > 1.67) {
                    results.push({
                        level: heights[i].level,
                        issue: `èˆ‡ä¸‹ä¸€ç¯€æ®µé«˜åº¦å·®ç•°éå¤§ (${ratio.toFixed(2)}x)`
                    });
                }
            }
            
            return results;
        }
        
        function buildVertebraEdges(vertebrae) {
            // æ¨¡ä»¿ slicer_codes.py çš„ _build_vertebra_edges
            const edges = {};
            
            for (let i = 0; i < vertebrae.length - 1; i++) {
                const current = vertebrae[i];
                const next = vertebrae[i + 1];
                
                // æå–æ¤é«”åç¨±ï¼ˆå¦‚ L4ï¼‰
                const vertebraName = current.level.split('/')[1];
                
                // å‰ç·£ï¼šxè¼ƒå°çš„é»
                const upperAnt = current.upperEndplate[0].x < current.upperEndplate[1].x ? 
                                current.upperEndplate[0] : current.upperEndplate[1];
                const lowerAnt = next.lowerEndplate[0].x < next.lowerEndplate[1].x ? 
                                next.lowerEndplate[0] : next.lowerEndplate[1];
                
                // å¾Œç·£ï¼šxè¼ƒå¤§çš„é»
                const upperPost = current.upperEndplate[0].x > current.upperEndplate[1].x ? 
                                 current.upperEndplate[0] : current.upperEndplate[1];
                const lowerPost = next.lowerEndplate[0].x > next.lowerEndplate[1].x ? 
                                 next.lowerEndplate[0] : next.lowerEndplate[1];
                
                edges[vertebraName] = {
                    anterior: [upperAnt, lowerAnt],
                    posterior: [upperPost, lowerPost]
                };
            }
            
            return edges;
        }
        
        // ==================== UI æ›´æ–° ====================
        function updateProgress() {
            const total = 5; // L5/S1 åˆ° L1/L2
            const current = vertebrae.length;
            const remaining = currentPoints.length;
            
            let text = `å·²å®Œæˆ ${current}/${total} å€‹æ¤é–“éš™`;
            if (remaining > 0) {
                text += ` (ç•¶å‰: ${remaining}/4 é»)`;
            }
            
            document.getElementById('progressText').textContent = text;
        }
        
        function updateAnalysis() {
            // æ›´æ–°æ¸¬é‡çµæœ
            let html = '';
            vertebrae.forEach(v => {
                const angle = calculateAngle(
                    v.lowerEndplate[0], v.lowerEndplate[1],
                    v.upperEndplate[0], v.upperEndplate[1]
                );
                const height = calculateDiscHeight(v.lowerEndplate, v.upperEndplate);
                
                html += `
                    <div class="measurement-card">
                        <div class="level-label">${v.level}</div>
                        <div class="metric">
                            <span class="metric-label">è§’åº¦:</span>
                            <span class="metric-value">${angle.toFixed(1)}Â°</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">æ¤é–“ç›¤é«˜åº¦:</span>
                            <span class="metric-value">${height.middle.toFixed(1)} px</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">å‰/å¾Œé«˜åº¦:</span>
                            <span class="metric-value">${height.anterior.toFixed(1)} / ${height.posterior.toFixed(1)}</span>
                        </div>
                    </div>
                `;
            });
            document.getElementById('measurementsList').innerHTML = html || '<p style="color: #6c757d;">å°šç„¡æ¸¬é‡æ•¸æ“š</p>';
            
            // æ›´æ–°ç•°å¸¸æª¢æ¸¬
            let abnormalHtml = '';
            
            if (vertebrae.length >= 2) {
                const listhesis = detectListhesis(vertebrae);
                const narrowing = detectDiscNarrowing(vertebrae);
                
                listhesis.forEach(l => {
                    abnormalHtml += `
                        <div class="measurement-card warning">
                            <strong>âš ï¸ ${l.type}</strong><br>
                            ${l.level}: æ»‘è„« ${l.shift}
                        </div>
                    `;
                });
                
                narrowing.forEach(n => {
                    abnormalHtml += `
                        <div class="measurement-card warning">
                            <strong>âš ï¸ ${n.level}</strong><br>
                            ${n.issue}
                        </div>
                    `;
                });
            }
            
            document.getElementById('abnormalitiesList').innerHTML = abnormalHtml || 
                '<p style="color: #28a745;">âœ… æœªæª¢æ¸¬åˆ°æ˜é¡¯ç•°å¸¸</p>';
        }
        
        // ==================== æ“ä½œåŠŸèƒ½ ====================
        function undoLastPoint() {
            if (currentPoints.length > 0) {
                currentPoints.pop();
            } else if (vertebrae.length > 0) {
                vertebrae.pop();
                updateAnalysis();
            }
            redraw();
            updateProgress();
        }
        
        function clearAll() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¨™è¨˜å—ï¼Ÿ')) {
                currentPoints = [];
                vertebrae = [];
                redraw();
                updateProgress();
                updateAnalysis();
            }
        }
        
        // ==================== åŒ¯å‡ºåŠŸèƒ½ ====================
        function exportTrainingData() {
            if (!originalImage || vertebrae.length === 0) {
                alert('âŒ è«‹å…ˆå®Œæˆæ¨™è¨»ï¼');
                return;
            }
            
            // å»ºç«‹ JSON æ•¸æ“šï¼ˆæ¨¡ä»¿ slicer_codes.py æ ¼å¼ï¼‰
            const measurements = vertebrae.map(v => {
                const angle = calculateAngle(
                    v.lowerEndplate[0], v.lowerEndplate[1],
                    v.upperEndplate[0], v.upperEndplate[1]
                );
                
                return {
                    level: v.level,
                    angle: parseFloat(angle.toFixed(1)),
                    angle_raw: parseFloat(angle.toFixed(1)),
                    confidence: 0.95,
                    measurement_method: "manual_web",
                    lowerEndplate: [
                        {x: v.lowerEndplate[0].x, y: v.lowerEndplate[0].y},
                        {x: v.lowerEndplate[1].x, y: v.lowerEndplate[1].y}
                    ],
                    upperEndplate: [
                        {x: v.upperEndplate[0].x, y: v.upperEndplate[0].y},
                        {x: v.upperEndplate[1].x, y: v.upperEndplate[1].y}
                    ]
                };
            });
            
            const vertebraEdges = buildVertebraEdges(vertebrae);
            
            const jsonData = {
                patient_id: "",
                study_id: "",
                study_date: new Date().toISOString().split('T')[0],
                spine_type: "L",
                image_type: "neutral",
                image_path: "",
                image_dimensions: {
                    width: originalImage.width,
                    height: originalImage.height
                },
                annotator: {
                    name: "",
                    id: "",
                    specialty: "",
                    experience_years: null
                },
                annotation_date: new Date().toISOString(),
                measurements: measurements,
                vertebra_edges: vertebraEdges,
                clinical_notes: {
                    original_report: ""
                },
                surgery_info: {
                    surgery_done: false
                }
            };
            
            // ä¸‹è¼‰ JSON
            const jsonBlob = new Blob([JSON.stringify(jsonData, null, 2)], {type: 'application/json'});
            const jsonUrl = URL.createObjectURL(jsonBlob);
            const jsonLink = document.createElement('a');
            const timestamp = new Date().getTime();
            jsonLink.href = jsonUrl;
            jsonLink.download = `spine_annotation_${timestamp}.json`;
            jsonLink.click();
            URL.revokeObjectURL(jsonUrl);
            
            // ä¸‹è¼‰å½±åƒ
            canvas.toBlob(blob => {
                const imgUrl = URL.createObjectURL(blob);
                const imgLink = document.createElement('a');
                imgLink.href = imgUrl;
                imgLink.download = `spine_image_${timestamp}.png`;
                imgLink.click();
                URL.revokeObjectURL(imgUrl);
            });
            
            alert('âœ… å·²åŒ¯å‡º JSON å’Œå½±åƒæª”æ¡ˆï¼\nè«‹å°‡é€™äº›æª”æ¡ˆæ”¾å…¥è¨“ç·´æ•¸æ“šè³‡æ–™å¤¾ã€‚');
        }
        
        function copyResults() {
            let report = 'è„Šæ¤çµ‚æ¿æ¨™è¨»çµæœ\n================\n\n';
            
            vertebrae.forEach(v => {
                const angle = calculateAngle(
                    v.lowerEndplate[0], v.lowerEndplate[1],
                    v.upperEndplate[0], v.upperEndplate[1]
                );
                const height = calculateDiscHeight(v.lowerEndplate, v.upperEndplate);
                
                report += `${v.level}:\n`;
                report += `  è§’åº¦: ${angle.toFixed(1)}Â°\n`;
                report += `  æ¤é–“ç›¤é«˜åº¦: ${height.middle.toFixed(1)} px\n`;
                report += `  å‰/å¾Œé«˜åº¦: ${height.anterior.toFixed(1)} / ${height.posterior.toFixed(1)}\n\n`;
            });
            
            if (vertebrae.length >= 2) {
                const listhesis = detectListhesis(vertebrae);
                const narrowing = detectDiscNarrowing(vertebrae);
                
                if (listhesis.length > 0 || narrowing.length > 0) {
                    report += 'ç•°å¸¸æª¢æ¸¬:\n';
                    listhesis.forEach(l => {
                        report += `  âš ï¸ ${l.level}: ${l.type} ${l.shift}\n`;
                    });
                    narrowing.forEach(n => {
                        report += `  âš ï¸ ${n.level}: ${n.issue}\n`;
                    });
                } else {
                    report += 'âœ… æœªæª¢æ¸¬åˆ°æ˜é¡¯ç•°å¸¸\n';
                }
            }
            
            report += `\nå ±å‘Šæ™‚é–“: ${new Date().toLocaleString('zh-TW')}`;
            
            navigator.clipboard.writeText(report).then(() => {
                alert('âœ… çµæœå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼');
            }).catch(() => {
                alert('âŒ è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½ã€‚');
            });
        }
    </script>
</body>
</html>

