<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è„Šæ¤æ¤é«”æ¨™è¨»å·¥å…· V2 - Vertebra Annotation</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 { font-size: 24px; }
        .header-info { font-size: 13px; opacity: 0.9; }

        .spine-type-selector {
            display: flex;
            gap: 10px;
        }

        .spine-type-btn {
            padding: 10px 25px;
            border: 2px solid white;
            background: transparent;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .spine-type-btn.active {
            background: white;
            color: #16213e;
        }

        .spine-type-btn:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 380px;
            min-height: calc(100vh - 150px);
        }

        .image-section {
            padding: 15px;
            background: #f0f2f5;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        button:hover { transform: translateY(-1px); }

        .btn-primary { background: #3498db; color: white; }
        .btn-success { background: #27ae60; color: white; }
        .btn-warning { background: #f39c12; color: white; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-secondary { background: #95a5a6; color: white; }
        .btn-info { background: #9b59b6; color: white; }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2c3e50;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            cursor: crosshair;
        }

        .zoom-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .sidebar {
            background: white;
            padding: 15px;
            overflow-y: auto;
            border-left: 2px solid #e0e0e0;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: #ecf0f1;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }

        .progress-bar {
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .current-task {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .current-task strong { color: #856404; }

        .vertebra-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .vertebra-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: #e9ecef;
            cursor: pointer;
        }

        .vertebra-header:hover { background: #dee2e6; }

        .vertebra-name {
            font-weight: bold;
            color: #495057;
        }

        .vertebra-name select {
            font-weight: bold;
            font-size: 14px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 2px 5px;
            background: white;
        }

        .vertebra-status {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            background: #6c757d;
            color: white;
        }

        .vertebra-status.complete { background: #28a745; }
        .vertebra-status.current { background: #ffc107; color: #333; }
        .vertebra-status.warning { background: #dc3545; }

        .vertebra-body {
            padding: 10px 12px;
            font-size: 12px;
            display: none;
        }

        .vertebra-body.show { display: block; }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .metric-row:last-child { border-bottom: none; }

        .metric-label { color: #6c757d; }
        .metric-value { font-weight: 500; }
        .metric-value.danger { color: #dc3545; font-weight: bold; }
        .metric-value.warning { color: #f39c12; }
        .metric-value.success { color: #27ae60; }

        .disc-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 12px;
        }

        .disc-card.abnormal {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .disc-header {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .disc-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 11px;
        }

        .disc-metric {
            background: rgba(255,255,255,0.2);
            padding: 5px 8px;
            border-radius: 4px;
        }

        .abnormality-card {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-left: 4px solid #dc3545;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .abnormality-card.warning {
            background: #fff3cd;
            border-color: #ffc107;
            border-left-color: #f39c12;
        }

        .export-panel {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 15px;
            border-radius: 8px;
        }

        .export-panel button {
            width: 100%;
            margin-top: 8px;
            justify-content: center;
        }

        .help-text {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
        }

        .point-guide {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-top: 10px;
            font-size: 11px;
        }

        .point-item {
            padding: 5px;
            border-radius: 4px;
            text-align: center;
        }

        .point-item.active {
            font-weight: bold;
            box-shadow: 0 0 0 2px #333;
        }

        .point-1 { background: #ffcccc; }
        .point-2 { background: #ccffcc; }
        .point-3 { background: #ccccff; }
        .point-4 { background: #ffffcc; }

        @media (max-width: 1200px) {
            .main-content { grid-template-columns: 1fr; }
            .sidebar { border-left: none; border-top: 2px solid #e0e0e0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>ğŸ¦´ è„Šæ¤æ¤é«”æ¨™è¨»å·¥å…· V2</h1>
                <div class="header-info">æ¯å€‹æ¤é«”æ¨™è¨»4å€‹è§’é»ï¼Œè‡ªå‹•è¨ˆç®—æ¤é–“ç›¤èˆ‡ç•°å¸¸</div>
            </div>
            <div class="spine-type-selector">
                <button class="spine-type-btn active" data-type="L" onclick="setSpineType('L')">
                    è…°æ¤ L-Spine
                </button>
                <button class="spine-type-btn" data-type="C" onclick="setSpineType('C')">
                    é ¸æ¤ C-Spine
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="image-section">
                <div class="toolbar">
                    <div class="toolbar-group">
                        <button class="btn-primary" onclick="loadImage()">ğŸ“‚ è¼‰å…¥å½±åƒ</button>
                        <button class="btn-primary" onclick="pasteImage()">ğŸ“‹ è²¼ä¸Š (Ctrl+V)</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="btn-warning" onclick="undoPoint()">â†¶ æ’¤éŠ·é»</button>
                        <button class="btn-danger" onclick="deleteCurrentVertebra()">ğŸ—‘ï¸ åˆªé™¤æ¤é«”</button>
                        <button class="btn-secondary" onclick="clearAll()">æ¸…é™¤å…¨éƒ¨</button>
                        <button class="btn-success" id="btnFinishEarly" onclick="finishEarly()" style="display:none;">âœ… çµæŸæ¨™è¨»</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="btn-info" onclick="toggleContrast()">ğŸ”† å°æ¯”å¢å¼·</button>
                        <button class="btn-secondary" onclick="zoomIn()">ğŸ”+</button>
                        <button class="btn-secondary" onclick="zoomOut()">ğŸ”-</button>
                        <button class="btn-secondary" onclick="resetZoom()">1:1</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    <div class="zoom-info">ç¸®æ”¾: <span id="zoomLevel">100</span>%</div>
                </div>
            </div>

            <div class="sidebar">
                <!-- é€²åº¦ -->
                <div class="section">
                    <div class="progress-text">æ¨™è¨»é€²åº¦: <span id="progressCount">0</span> / <span id="totalCount">6</span> æ¤é«”</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- ç•¶å‰ä»»å‹™ -->
                <div class="current-task" id="currentTask">
                    <strong>ğŸ“ ä¸‹ä¸€æ­¥ï¼š</strong><span id="taskText">è«‹å…ˆè¼‰å…¥æˆ–è²¼ä¸Šå½±åƒ</span>
                    <div class="point-guide" id="pointGuide" style="display: none;">
                        <div class="point-item point-1" id="guide1">â‘  å‰ä¸Šè§’</div>
                        <div class="point-item point-2" id="guide2">â‘¡ å¾Œä¸Šè§’</div>
                        <div class="point-item point-3" id="guide3">â‘¢ å¾Œä¸‹è§’</div>
                        <div class="point-item point-4" id="guide4">â‘£ å‰ä¸‹è§’</div>
                    </div>
                </div>

                <!-- æ¤é«”åˆ—è¡¨ -->
                <div class="section">
                    <div class="section-title">ğŸ“‹ æ¤é«”åˆ—è¡¨</div>
                    <div id="vertebraList"></div>
                </div>

                <!-- æ¤é–“ç›¤åˆ†æ -->
                <div class="section">
                    <div class="section-title">ğŸ’¿ æ¤é–“ç›¤åˆ†æ</div>
                    <div id="discAnalysis"></div>
                </div>

                <!-- ç•°å¸¸æª¢æ¸¬ -->
                <div class="section">
                    <div class="section-title">âš ï¸ ç•°å¸¸æª¢æ¸¬</div>
                    <div id="abnormalities"></div>
                </div>

                <!-- åŒ¯å‡º -->
                <div class="export-panel">
                    <strong>ğŸ’¾ åŒ¯å‡ºæ•¸æ“š</strong>
                    <div class="help-text">å®Œæˆæ¨™è¨»å¾ŒåŒ¯å‡ºè¨“ç·´æ•¸æ“š</div>
                    <button class="btn-success" onclick="exportData()">åŒ¯å‡º JSON</button>
                    <button class="btn-info" onclick="exportReport()">åŒ¯å‡ºå ±å‘Š</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="handleFileSelect(event)">

    <script>
        // ==================== é…ç½® ====================
        // æ¤é«”åˆ—è¡¨ï¼šæŒ‰è§£å‰–å­¸ç”±ä¸Šåˆ°ä¸‹æ’åˆ—
        // boundary æ¨™è¨˜é‚Šç•Œæ¤é«”ï¼š'upper' = åªæœ‰ä¸Šçµ‚æ¿(2é»)ï¼Œ'lower' = åªæœ‰ä¸‹çµ‚æ¿(2é»)
        const CONFIG = {
            L: {
                vertebrae: ['T12', 'L1', 'L2', 'L3', 'L4', 'L5', 'S1'],
                boundary: { 'T12': 'lower', 'S1': 'upper' },
                direction: 'bottom-up', // ç”±ä¸‹åˆ°ä¸Šæ¨™è¨»
                expectedHeightPattern: 'L4L5_highest',
            },
            C: {
                vertebrae: ['C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'T1'],
                boundary: { 'C2': 'lower', 'T1': 'upper' },
                direction: 'top-down', // ç”±ä¸Šåˆ°ä¸‹æ¨™è¨»
                expectedHeightPattern: 'increasing',
            }
        };

        const COLORS = {
            point1: '#ff6b6b', // å‰ä¸Šè§’ - ç´…
            point2: '#51cf66', // å¾Œä¸Šè§’ - ç¶ 
            point3: '#339af0', // å¾Œä¸‹è§’ - è—
            point4: '#fcc419', // å‰ä¸‹è§’ - é»ƒ
            line: '#ffffff',
            currentVertebra: '#00ff00',
            completedVertebra: '#3498db',
            abnormalVertebra: '#e74c3c',
            boundaryVertebra: '#9b59b6'
        };

        // ==================== ç‹€æ…‹ ====================
        let canvas, ctx;
        let originalImage = null;
        let spineType = 'L';
        let vertebrae = [];
        let currentPoints = [];
        let zoom = 1;
        let panX = 0, panY = 0;
        let isDragging = false;
        let wasDragging = false; // è¿½è¹¤æ˜¯å¦å¯¦éš›æ‹–æ›³éï¼ˆç”¨æ–¼æ±ºå®šæ˜¯å¦é˜»æ­¢å³éµé¸å–®ï¼‰
        let lastMousePos = {x: 0, y: 0};
        let contrastEnhanced = false;
        let processedImage = null;
        let annotationFinished = false; // æå‰çµæŸæ¨™è¨»

        // ==================== è¼”åŠ©å‡½æ•¸ ====================
        function getNextVertebraName() {
            if (annotationFinished) return null;
            const config = CONFIG[spineType];
            const idx = vertebrae.length;
            if (idx >= config.vertebrae.length) return null;
            if (config.direction === 'bottom-up') {
                return config.vertebrae[config.vertebrae.length - 1 - idx];
            } else {
                return config.vertebrae[idx];
            }
        }

        function isBoundary(name) {
            const config = CONFIG[spineType];
            return config.boundary[name] || null;
        }

        function getRequiredPoints(name) {
            // é‚Šç•Œæ¤é«”åªéœ€ 2 é»ï¼Œå®Œæ•´æ¤é«” 4 é»
            return isBoundary(name) ? 2 : 4;
        }

        function getPointLabelsForVertebra(name) {
            const b = isBoundary(name);
            if (b === 'upper') {
                // S1/T1: åªæœ‰ä¸Šçµ‚æ¿ â†’ å‰ä¸Šè§’, å¾Œä¸Šè§’
                return ['å‰ä¸Šè§’', 'å¾Œä¸Šè§’'];
            } else if (b === 'lower') {
                // T12/C2: åªæœ‰ä¸‹çµ‚æ¿ â†’ å‰ä¸‹è§’, å¾Œä¸‹è§’
                return ['å‰ä¸‹è§’', 'å¾Œä¸‹è§’'];
            }
            return ['å‰ä¸Šè§’', 'å¾Œä¸Šè§’', 'å¾Œä¸‹è§’', 'å‰ä¸‹è§’'];
        }

        // ==================== åˆå§‹åŒ– ====================
        window.onload = function() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            canvas.addEventListener('contextmenu', e => {
                // åªåœ¨æ‹–æ›³å¹³ç§»æ™‚é˜»æ­¢å³éµé¸å–®ï¼Œéœæ­¢å³éµå…è¨±ã€Œå¦å­˜åœ–ç‰‡ã€
                if (wasDragging) {
                    e.preventDefault();
                    wasDragging = false;
                }
            });
            document.addEventListener('paste', handlePaste);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);

            document.addEventListener('keydown', handleKeyDown);

            updateUI();
        };

        // ==================== å½±åƒè™•ç† ====================
        function loadImage() {
            document.getElementById('fileInput').click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) loadImageFromFile(file);
        }

        function handlePaste(e) {
            e.preventDefault();
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    loadImageFromFile(item.getAsFile());
                    return;
                }
            }
        }

        function pasteImage() {
            navigator.clipboard.read().then(data => {
                for (let item of data) {
                    for (let type of item.types) {
                        if (type.startsWith('image/')) {
                            item.getType(type).then(blob => loadImageFromFile(blob));
                            return;
                        }
                    }
                }
                alert('å‰ªè²¼ç°¿ä¸­æ²’æœ‰åœ–ç‰‡');
            }).catch(() => alert('è«‹ä½¿ç”¨ Ctrl+V è²¼ä¸Š'));
        }

        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    resetZoom();
                    contrastEnhanced = false;
                    processedImage = null;
                    redraw();
                    updateUI();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function toggleContrast() {
            if (!originalImage) return;
            contrastEnhanced = !contrastEnhanced;

            if (contrastEnhanced && !processedImage) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = originalImage.width;
                tempCanvas.height = originalImage.height;
                tempCtx.drawImage(originalImage, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;

                let min = 255, max = 0;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                    min = Math.min(min, gray);
                    max = Math.max(max, gray);
                }

                const range = max - min || 1;
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        data[i+j] = Math.round(((data[i+j] - min) / range) * 255);
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);
                processedImage = new Image();
                processedImage.src = tempCanvas.toDataURL();
                processedImage.onload = () => redraw();
            } else {
                redraw();
            }
        }

        // ==================== ç¸®æ”¾å’Œå¹³ç§» ====================
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, zoom * delta));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            panX = mouseX - (mouseX - panX) * (newZoom / zoom);
            panY = mouseY - (mouseY - panY) * (newZoom / zoom);

            zoom = newZoom;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100);
            redraw();
        }

        function handleMouseDown(e) {
            if (e.button === 1 || e.button === 2) {
                isDragging = true;
                lastMousePos = {x: e.clientX, y: e.clientY};
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (isDragging) {
                panX += e.clientX - lastMousePos.x;
                panY += e.clientY - lastMousePos.y;
                lastMousePos = {x: e.clientX, y: e.clientY};
                wasDragging = true;
                redraw();
            }
        }

        function handleMouseUp() {
            isDragging = false;
            // wasDragging ç”± contextmenu handler é‡ç½®ï¼Œä¸åœ¨æ­¤é‡ç½®
        }

        function zoomIn() { zoom = Math.min(5, zoom * 1.2); document.getElementById('zoomLevel').textContent = Math.round(zoom * 100); redraw(); }
        function zoomOut() { zoom = Math.max(0.1, zoom / 1.2); document.getElementById('zoomLevel').textContent = Math.round(zoom * 100); redraw(); }
        function resetZoom() { zoom = 1; panX = 0; panY = 0; document.getElementById('zoomLevel').textContent = '100'; redraw(); }

        // ==================== è„Šæ¤é¡å‹ ====================
        function setSpineType(type) {
            if (vertebrae.length > 0) {
                if (!confirm('åˆ‡æ›è„Šæ¤é¡å‹æœƒæ¸…é™¤ç¾æœ‰æ¨™è¨»ï¼Œç¢ºå®šå—ï¼Ÿ')) return;
                vertebrae = [];
                currentPoints = [];
                annotationFinished = false;
            }
            spineType = type;
            document.querySelectorAll('.spine-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            updateUI();
            redraw();
        }

        // ==================== é»æ“Šè™•ç† ====================
        function handleCanvasClick(event) {
            if (!originalImage || isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            const x = (canvasX - panX) / zoom;
            const y = (canvasY - panY) / zoom;

            if (x < 0 || x > originalImage.width || y < 0 || y > originalImage.height) return;

            const nextName = getNextVertebraName();
            if (!nextName) {
                alert('å·²é”åˆ°æœ€å¤§æ¤é«”æ•¸é‡');
                return;
            }

            const requiredPts = getRequiredPoints(nextName);
            currentPoints.push({x, y});

            if (currentPoints.length === requiredPts) {
                const boundaryType = isBoundary(nextName);
                let sortedPoints;

                if (boundaryType === 'upper') {
                    // S1/T1: åªæœ‰å‰ä¸Šè§’ã€å¾Œä¸Šè§’
                    sortedPoints = normalizeEndplate(currentPoints);
                } else if (boundaryType === 'lower') {
                    // T12/C2: åªæœ‰å‰ä¸‹è§’ã€å¾Œä¸‹è§’
                    sortedPoints = normalizeEndplate(currentPoints);
                } else {
                    // å®Œæ•´æ¤é«”: 4 é»
                    sortedPoints = normalizePoints(currentPoints);
                }

                vertebrae.push({
                    name: nextName,
                    points: sortedPoints,
                    boundaryType: boundaryType,
                    anteriorHeight: null,
                    posteriorHeight: null
                });

                calculateVertebraMetrics(vertebrae.length - 1);
                currentPoints = [];
            }

            redraw();
            updateUI();
        }

        function normalizeEndplate(points) {
            // 2 é»: x è¼ƒå°çš„åœ¨å‰ï¼ˆanteriorï¼‰
            const sorted = [...points].sort((a, b) => a.x - b.x);
            return [sorted[0], sorted[1]]; // [anterior, posterior]
        }

        function normalizePoints(points) {
            // 4 é»: [å‰ä¸Š, å¾Œä¸Š, å¾Œä¸‹, å‰ä¸‹]
            const sorted = [...points].sort((a, b) => a.y - b.y);
            const topPoints = sorted.slice(0, 2);
            const bottomPoints = sorted.slice(2, 4);

            topPoints.sort((a, b) => a.x - b.x);
            bottomPoints.sort((a, b) => a.x - b.x);

            return [
                topPoints[0],     // å‰ä¸Šè§’ (anterior-superior)
                topPoints[1],     // å¾Œä¸Šè§’ (posterior-superior)
                bottomPoints[1],  // å¾Œä¸‹è§’ (posterior-inferior)
                bottomPoints[0]   // å‰ä¸‹è§’ (anterior-inferior)
            ];
        }

        function calculateVertebraMetrics(index) {
            const v = vertebrae[index];
            if (v.boundaryType) {
                // é‚Šç•Œæ¤é«”åªæœ‰ä¸€æ¢çµ‚æ¿ï¼Œç„¡æ³•è¨ˆç®—å‰å¾Œç·£é«˜åº¦
                v.anteriorHeight = null;
                v.posteriorHeight = null;
                return;
            }
            const pts = v.points;
            v.anteriorHeight = Math.sqrt(
                Math.pow(pts[3].x - pts[0].x, 2) + Math.pow(pts[3].y - pts[0].y, 2)
            );
            v.posteriorHeight = Math.sqrt(
                Math.pow(pts[2].x - pts[1].x, 2) + Math.pow(pts[2].y - pts[1].y, 2)
            );
        }

        // ==================== å–å¾—çµ‚æ¿åº§æ¨™ï¼ˆçµ±ä¸€ä»‹é¢ï¼‰====================
        function getUpperEndplate(v) {
            // å–å¾—æ¤é«”ä¸Šçµ‚æ¿çš„ [anterior, posterior] åº§æ¨™
            if (v.boundaryType === 'upper') {
                // S1/T1: åªæœ‰ä¸Šçµ‚æ¿ [å‰ä¸Š, å¾Œä¸Š]
                return [v.points[0], v.points[1]];
            } else if (v.boundaryType === 'lower') {
                // T12/C2: æ²’æœ‰ä¸Šçµ‚æ¿
                return null;
            }
            // å®Œæ•´æ¤é«”: [å‰ä¸Š, å¾Œä¸Š]
            return [v.points[0], v.points[1]];
        }

        function getLowerEndplate(v) {
            // å–å¾—æ¤é«”ä¸‹çµ‚æ¿çš„ [anterior, posterior] åº§æ¨™
            if (v.boundaryType === 'lower') {
                // T12/C2: åªæœ‰ä¸‹çµ‚æ¿ [å‰ä¸‹, å¾Œä¸‹]
                return [v.points[0], v.points[1]];
            } else if (v.boundaryType === 'upper') {
                // S1/T1: æ²’æœ‰ä¸‹çµ‚æ¿
                return null;
            }
            // å®Œæ•´æ¤é«”: [å‰ä¸‹, å¾Œä¸‹]
            return [v.points[3], v.points[2]];
        }

        function getPosteriorPoints(v) {
            // å–å¾—å¾Œç·£çš„ [ä¸Š, ä¸‹] åº§æ¨™ï¼Œç”¨æ–¼æ»‘è„«æª¢æ¸¬
            if (v.boundaryType === 'upper') {
                // S1/T1: åªæœ‰ä¸Šçµ‚æ¿ï¼Œå¾Œç·£ä¸Šé» = posterior-superior
                return { top: v.points[1], bottom: null };
            } else if (v.boundaryType === 'lower') {
                // T12/C2: åªæœ‰ä¸‹çµ‚æ¿ï¼Œå¾Œç·£ä¸‹é» = posterior-inferior
                return { top: null, bottom: v.points[1] };
            }
            return { top: v.points[1], bottom: v.points[2] };
        }

        // ==================== å¿«æ·éµ ====================
        function handleKeyDown(e) {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undoPoint();
            }
        }

        function undoPoint() {
            if (currentPoints.length > 0) {
                currentPoints.pop();
            } else if (vertebrae.length > 0) {
                vertebrae.pop();
                annotationFinished = false; // æ’¤éŠ·å¾Œå¯ç¹¼çºŒæ¨™è¨»
            }
            redraw();
            updateUI();
        }

        function deleteCurrentVertebra() {
            if (currentPoints.length > 0) {
                currentPoints = [];
            } else if (vertebrae.length > 0) {
                vertebrae.pop();
                annotationFinished = false; // åˆªé™¤æ¤é«”å¾Œå¯ç¹¼çºŒæ¨™è¨»
            }
            redraw();
            updateUI();
        }

        function clearAll() {
            if (confirm('ç¢ºå®šæ¸…é™¤æ‰€æœ‰æ¨™è¨»ï¼Ÿ')) {
                vertebrae = [];
                currentPoints = [];
                annotationFinished = false;
                redraw();
                updateUI();
            }
        }

        function finishEarly() {
            if (vertebrae.length < 2) {
                alert('è‡³å°‘éœ€è¦æ¨™è¨» 2 å€‹æ¤é«”æ‰èƒ½çµæŸ');
                return;
            }
            if (currentPoints.length > 0) {
                if (!confirm('ç›®å‰æœ‰æœªå®Œæˆçš„æ¨™è¨»é»ï¼Œç¢ºå®šè¦æ¨æ£„ä¸¦çµæŸå—ï¼Ÿ')) return;
                currentPoints = [];
            }
            annotationFinished = true;
            redraw();
            updateUI();
        }

        // ==================== ç¹ªè£½ ====================
        function redraw() {
            if (!originalImage) {
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('è«‹è¼‰å…¥æˆ–è²¼ä¸Šè„Šæ¤ X å…‰å½±åƒ', canvas.width/2, canvas.height/2);
                return;
            }

            ctx.save();
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            const img = (contrastEnhanced && processedImage) ? processedImage : originalImage;
            ctx.drawImage(img, 0, 0);

            // ç¹ªè£½å·²å®Œæˆçš„æ¤é«”
            vertebrae.forEach((v, idx) => {
                const isAbnormal = !v.boundaryType && checkVertebraAbnormal(v);
                const color = v.boundaryType ? COLORS.boundaryVertebra :
                              isAbnormal ? COLORS.abnormalVertebra : COLORS.completedVertebra;
                drawVertebra(v, color, idx);
            });

            // ç¹ªè£½ç•¶å‰é»
            const nextName = getNextVertebraName();
            const labels = nextName ? getPointLabelsForVertebra(nextName) : [];
            currentPoints.forEach((p, idx) => {
                const colors = [COLORS.point1, COLORS.point2, COLORS.point3, COLORS.point4];
                drawPoint(p, colors[idx], idx + 1);
                if (idx > 0) drawLine(currentPoints[idx-1], p, '#ffffff', 2);
            });

            // é è¦½é–‰åˆç·š
            const reqPts = nextName ? getRequiredPoints(nextName) : 4;
            if (currentPoints.length === reqPts - 1 && reqPts === 4) {
                ctx.setLineDash([5, 5]);
                drawLine(currentPoints[currentPoints.length - 1], currentPoints[0], '#ffffff', 1);
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        function drawVertebra(v, color, index) {
            const pts = v.points;

            if (v.boundaryType) {
                // é‚Šç•Œæ¤é«”ï¼šåªç•«ä¸€æ¢çµ‚æ¿ç·š
                ctx.strokeStyle = color;
                ctx.lineWidth = 3 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[1].x, pts[1].y);
                ctx.stroke();

                // æ¨™è¨˜å‰ç·£å’Œå¾Œç·£ç«¯é»
                drawPoint(pts[0], COLORS.point1, null, 5 / zoom); // å‰
                drawPoint(pts[1], COLORS.point2, null, 5 / zoom); // å¾Œ

                // æ¨™ç±¤
                const cx = (pts[0].x + pts[1].x) / 2;
                const cy = (pts[0].y + pts[1].y) / 2;
                const offset = v.boundaryType === 'upper' ? -20 : 20;
                drawLabel(v.name, cx, cy + offset / zoom);
            } else {
                // å®Œæ•´æ¤é«”
                ctx.fillStyle = color + '30';
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                pts.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                pts.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.stroke();

                // å‰ç·£
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 3 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[3].x, pts[3].y);
                ctx.stroke();

                // å¾Œç·£
                ctx.strokeStyle = '#339af0';
                ctx.beginPath();
                ctx.moveTo(pts[1].x, pts[1].y);
                ctx.lineTo(pts[2].x, pts[2].y);
                ctx.stroke();

                pts.forEach((p, i) => {
                    const colors = [COLORS.point1, COLORS.point2, COLORS.point3, COLORS.point4];
                    drawPoint(p, colors[i], null, 4 / zoom);
                });

                const centerX = (pts[0].x + pts[2].x) / 2;
                const centerY = (pts[0].y + pts[2].y) / 2;
                drawLabel(v.name, centerX, centerY);
            }
        }

        function drawLabel(text, x, y) {
            const fontSize = Math.max(12, 16 / zoom);
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const textWidth = ctx.measureText(text).width;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x - textWidth/2 - 4, y - fontSize/2 - 2, textWidth + 8, fontSize + 4);
            ctx.fillStyle = '#fff';
            ctx.fillText(text, x, y);
        }

        function drawPoint(p, color, label, radius = 6) {
            const r = (typeof radius === 'number' ? radius : 6) / (radius > 1 ? 1 : zoom);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5 / zoom;
            ctx.stroke();

            if (label) {
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${10/zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label.toString(), p.x, p.y);
            }
        }

        function drawLine(p1, p2, color, width) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width / zoom;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // ==================== åˆ†æè¨ˆç®— ====================
        function checkVertebraAbnormal(v) {
            // å›å‚³ç•°å¸¸é¡å‹: false / 'anteriorWedging' / 'crushDeformity'
            if (!v.anteriorHeight || !v.posteriorHeight) return false;
            if (v.anteriorHeight < v.posteriorHeight * 0.75) return 'anteriorWedging';
            if (v.anteriorHeight > v.posteriorHeight * 1.25) return 'crushDeformity';
            return false;
        }

        function getAnatomicalOrder() {
            // å°‡æ¤é«”æŒ‰è§£å‰–å­¸ç”±ä¸Šåˆ°ä¸‹æ’åˆ—
            const config = CONFIG[spineType];
            const order = config.vertebrae;
            return [...vertebrae].sort((a, b) => order.indexOf(a.name) - order.indexOf(b.name));
        }

        function getDiscLevel(upperName, lowerName) {
            // æ°¸é æŒ‰è§£å‰–å­¸é †åºå‘½åï¼šä¸Šæ¤é«”/ä¸‹æ¤é«”
            const config = CONFIG[spineType];
            const order = config.vertebrae;
            const iUpper = order.indexOf(upperName);
            const iLower = order.indexOf(lowerName);
            if (iUpper < iLower) return `${upperName}/${lowerName}`;
            return `${lowerName}/${upperName}`;
        }

        function calculateDiscMetrics(upperV, lowerV) {
            // ä¸Šæ¤é«”çš„ä¸‹çµ‚æ¿ vs ä¸‹æ¤é«”çš„ä¸Šçµ‚æ¿
            const upperLower = getLowerEndplate(upperV); // [anterior, posterior]
            const lowerUpper = getUpperEndplate(lowerV); // [anterior, posterior]

            if (!upperLower || !lowerUpper) return null;

            const anteriorHeight = Math.sqrt(
                Math.pow(lowerUpper[0].x - upperLower[0].x, 2) +
                Math.pow(lowerUpper[0].y - upperLower[0].y, 2)
            );

            const posteriorHeight = Math.sqrt(
                Math.pow(lowerUpper[1].x - upperLower[1].x, 2) +
                Math.pow(lowerUpper[1].y - upperLower[1].y, 2)
            );

            const middleHeight = (anteriorHeight + posteriorHeight) / 2;

            const upperAngle = Math.atan2(
                upperLower[1].y - upperLower[0].y,
                upperLower[1].x - upperLower[0].x
            );
            const lowerAngle = Math.atan2(
                lowerUpper[1].y - lowerUpper[0].y,
                lowerUpper[1].x - lowerUpper[0].x
            );
            let wedgeAngle = Math.abs(upperAngle - lowerAngle) * 180 / Math.PI;
            if (wedgeAngle > 90) wedgeAngle = 180 - wedgeAngle;

            return { anteriorHeight, posteriorHeight, middleHeight, wedgeAngle };
        }

        function checkListhesis() {
            const results = [];
            const ordered = getAnatomicalOrder();
            // åªå–æœ‰å¾Œç·£è³‡è¨Šçš„æ¤é«”
            const withPosterior = ordered.filter(v => {
                const p = getPosteriorPoints(v);
                return p.top || p.bottom;
            });

            if (withPosterior.length < 3) return results;

            // å–å¾Œç·£ä»£è¡¨é»ï¼šå®Œæ•´æ¤é«”ç”¨ä¸­é»ï¼Œé‚Šç•Œæ¤é«”ç”¨æœ‰çš„é‚£å€‹é»
            const posteriorPts = withPosterior.map(v => {
                const p = getPosteriorPoints(v);
                let x, y;
                if (p.top && p.bottom) {
                    x = (p.top.x + p.bottom.x) / 2;
                    y = (p.top.y + p.bottom.y) / 2;
                } else if (p.top) {
                    x = p.top.x; y = p.top.y;
                } else {
                    x = p.bottom.x; y = p.bottom.y;
                }
                return { name: v.name, x, y, v };
            });

            const first = posteriorPts[0];
            const last = posteriorPts[posteriorPts.length - 1];
            const lineLen = Math.sqrt(Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2));
            if (lineLen === 0) return results;

            for (let i = 1; i < posteriorPts.length - 1; i++) {
                const p = posteriorPts[i];
                const distance = Math.abs(
                    (last.y - first.y) * p.x - (last.x - first.x) * p.y +
                    last.x * first.y - last.y * first.x
                ) / lineLen;

                // ä½¿ç”¨ä¸Šçµ‚æ¿å¯¬åº¦ä½œç‚ºåƒè€ƒ
                const upper = getUpperEndplate(p.v);
                if (!upper) continue;
                const width = Math.abs(upper[1].x - upper[0].x);
                if (width === 0) continue;

                const shiftPercent = (distance / width) * 100;

                if (shiftPercent > 5) {
                    const dy = last.y - first.y;
                    const expectedX = dy !== 0 ?
                        first.x + (p.y - first.y) * (last.x - first.x) / dy :
                        first.x;
                    const type = p.x > expectedX ? 'Retrolisthesis' : 'Anterolisthesis';

                    results.push({
                        level: p.name,
                        type: type,
                        shift: shiftPercent.toFixed(1)
                    });
                }
            }
            return results;
        }

        function checkHeightProgression() {
            const results = [];
            const ordered = getAnatomicalOrder();
            const discHeights = [];

            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;
                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                discHeights.push({ level, height: metrics.middleHeight });
            }

            if (discHeights.length < 2) return results;

            const config = CONFIG[spineType];

            if (config.expectedHeightPattern === 'L4L5_highest') {
                const l45 = discHeights.find(d => d.level === 'L4/L5');

                if (l45) {
                    discHeights.forEach(d => {
                        if (d.level !== 'L4/L5' && d.level !== 'L5/S1') {
                            if (d.height > l45.height * 1.1) {
                                results.push({
                                    level: d.level,
                                    issue: `æ¤é–“ç›¤é«˜åº¦ç•°å¸¸åé«˜ï¼ˆé«˜æ–¼ L4/L5ï¼‰`,
                                    severity: 'warning'
                                });
                            }
                        }
                    });
                }

                for (let i = 0; i < discHeights.length - 1; i++) {
                    if (discHeights[i + 1].level === 'L5/S1') continue;
                    if (discHeights[i].height > discHeights[i + 1].height * 1.3) {
                        results.push({
                            level: discHeights[i].level,
                            issue: `æ¤é–“ç›¤é«˜åº¦éé€²ç•°å¸¸`,
                            severity: 'warning'
                        });
                    }
                }
            } else if (config.expectedHeightPattern === 'increasing') {
                for (let i = 0; i < discHeights.length - 1; i++) {
                    if (discHeights[i].height > discHeights[i + 1].height * 1.2) {
                        results.push({
                            level: discHeights[i].level,
                            issue: `æ¤é–“ç›¤é«˜åº¦éé€²ç•°å¸¸ï¼ˆæ‡‰è¶Šä¾†è¶Šé«˜ï¼‰`,
                            severity: 'warning'
                        });
                    }
                }
            }
            return results;
        }

        // ==================== UI æ›´æ–° ====================
        function updateUI() {
            const config = CONFIG[spineType];
            const total = config.vertebrae.length;
            const completed = vertebrae.length;

            document.getElementById('progressCount').textContent = completed;
            document.getElementById('totalCount').textContent = total;
            document.getElementById('progressFill').style.width = `${(completed / total) * 100}%`;

            // é¡¯ç¤º/éš±è—ã€ŒçµæŸæ¨™è¨»ã€æŒ‰éˆ•ï¼šè‡³å°‘ 2 å€‹æ¤é«”ä¸”å°šæœªçµæŸ
            const btnFinish = document.getElementById('btnFinishEarly');
            if (btnFinish) {
                btnFinish.style.display = (completed >= 2 && !annotationFinished && completed < total) ? '' : 'none';
            }

            updateCurrentTask();
            updateVertebraList();
            updateDiscAnalysis();
            updateAbnormalities();
        }

        function updateCurrentTask() {
            const taskText = document.getElementById('taskText');
            const pointGuide = document.getElementById('pointGuide');

            if (!originalImage) {
                taskText.textContent = 'è«‹å…ˆè¼‰å…¥æˆ–è²¼ä¸Šå½±åƒ';
                pointGuide.style.display = 'none';
                return;
            }

            const nextName = getNextVertebraName();
            if (!nextName) {
                taskText.textContent = 'âœ… æ¨™è¨»å®Œæˆï¼å¯ä»¥åŒ¯å‡ºæ•¸æ“š';
                pointGuide.style.display = 'none';
                return;
            }

            const required = getRequiredPoints(nextName);
            const labels = getPointLabelsForVertebra(nextName);
            const bType = isBoundary(nextName);
            const bHint = bType === 'upper' ? '(ä¸Šçµ‚æ¿)' :
                          bType === 'lower' ? '(ä¸‹çµ‚æ¿)' : '';

            taskText.textContent = `æ¨™è¨» ${nextName} ${bHint} (${currentPoints.length}/${required} é»)`;
            pointGuide.style.display = 'grid';

            // æ›´æ–°é»å¼•å° â€” å‹•æ…‹é¡¯ç¤º
            const guideContainer = document.getElementById('pointGuide');
            let guideHtml = '';
            labels.forEach((label, i) => {
                const isActive = i === currentPoints.length;
                const colorClasses = ['point-1', 'point-2', 'point-3', 'point-4'];
                guideHtml += `<div class="point-item ${colorClasses[i]} ${isActive ? 'active' : ''}">
                    ${i + 1} ${label}
                </div>`;
            });
            guideContainer.innerHTML = guideHtml;
        }

        function updateVertebraList() {
            const list = document.getElementById('vertebraList');
            const config = CONFIG[spineType];

            if (vertebrae.length === 0) {
                list.innerHTML = '<div style="color: #999; font-size: 12px; padding: 10px;">å°šæœªæ¨™è¨»æ¤é«”</div>';
                return;
            }

            let html = '';
            vertebrae.forEach((v, idx) => {
                const abnormalType = !v.boundaryType && checkVertebraAbnormal(v);
                const isBound = !!v.boundaryType;
                const statusClass = abnormalType ? 'warning' : 'complete';
                const abnormalLabel = abnormalType === 'anteriorWedging' ? 'âš ï¸ å‰ç·£å£“è¿«' :
                                     abnormalType === 'crushDeformity' ? 'âš ï¸ Crush' : '';
                const statusText = isBound ? (v.boundaryType === 'upper' ? 'ä¸Šçµ‚æ¿' : 'ä¸‹çµ‚æ¿') :
                                   abnormalType ? abnormalLabel : 'âœ“ å®Œæˆ';

                // é¸å–®åŒ…å«æ‰€æœ‰æ¤é«”åç¨±
                const allNames = config.vertebrae;

                html += `
                    <div class="vertebra-card">
                        <div class="vertebra-header" onclick="toggleVertebraBody(${idx})">
                            <div class="vertebra-name">
                                <select onchange="changeVertebraName(${idx}, this.value)" onclick="event.stopPropagation()">
                                    ${allNames.map(name =>
                                        `<option value="${name}" ${v.name === name ? 'selected' : ''}>${name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <span class="vertebra-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="vertebra-body" id="vertebra-body-${idx}">`;

                if (!isBound) {
                    html += `
                            <div class="metric-row">
                                <span class="metric-label">å‰ç·£é«˜åº¦:</span>
                                <span class="metric-value">${v.anteriorHeight?.toFixed(1) || '-'} px</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">å¾Œç·£é«˜åº¦:</span>
                                <span class="metric-value">${v.posteriorHeight?.toFixed(1) || '-'} px</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">å‰/å¾Œæ¯”ä¾‹:</span>
                                <span class="metric-value ${isAbnormal ? 'danger' : ''}">${v.anteriorHeight && v.posteriorHeight ? (v.anteriorHeight / v.posteriorHeight * 100).toFixed(0) + '%' : '-'}</span>
                            </div>
                            ${abnormalType === 'anteriorWedging' ? '<div style="color: #dc3545; font-size: 11px; margin-top: 5px;">âš ï¸ ç–‘ä¼¼å‰ç·£å£“è¿«æ€§éª¨æŠ˜ (Anterior Wedging)</div>' : ''}
                            ${abnormalType === 'crushDeformity' ? '<div style="color: #dc3545; font-size: 11px; margin-top: 5px;">âš ï¸ ç–‘ä¼¼ Crush Deformity Compression Fracture</div>' : ''}`;
                } else {
                    html += `<div style="color: #6c757d; font-size: 11px;">é‚Šç•Œæ¤é«” â€” åƒ…æ¨™è¨˜${v.boundaryType === 'upper' ? 'ä¸Š' : 'ä¸‹'}çµ‚æ¿</div>`;
                }

                html += `</div></div>`;
            });

            list.innerHTML = html;
        }

        function toggleVertebraBody(idx) {
            document.getElementById(`vertebra-body-${idx}`).classList.toggle('show');
        }

        function changeVertebraName(idx, newName) {
            const oldBoundary = isBoundary(vertebrae[idx].name);
            const newBoundary = isBoundary(newName);

            // å¦‚æœé‚Šç•Œé¡å‹æ”¹è®Šï¼ˆ2é» â†” 4é»ï¼‰ï¼Œæé†’ä½¿ç”¨è€…
            if (oldBoundary !== newBoundary) {
                alert(`æ³¨æ„ï¼š${newName} ${newBoundary ? 'æ˜¯é‚Šç•Œæ¤é«”ï¼ˆ' + (newBoundary === 'upper' ? 'ä¸Šçµ‚æ¿' : 'ä¸‹çµ‚æ¿') + 'ï¼‰' : 'æ˜¯å®Œæ•´æ¤é«”ï¼ˆ4é»ï¼‰'}ã€‚\né»æ•¸ä¸åŒ¹é…ï¼Œå»ºè­°åˆªé™¤å¾Œé‡æ–°æ¨™è¨»ã€‚`);
            }

            vertebrae[idx].name = newName;
            vertebrae[idx].boundaryType = newBoundary;
            updateUI();
            redraw();
        }

        function updateDiscAnalysis() {
            const container = document.getElementById('discAnalysis');
            const ordered = getAnatomicalOrder();

            if (ordered.length < 2) {
                container.innerHTML = '<div style="color: #999; font-size: 12px; padding: 10px;">éœ€è¦è‡³å°‘ 2 å€‹æ¤é«”æ‰èƒ½åˆ†ææ¤é–“ç›¤</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;

                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                const isNarrow = metrics.middleHeight < 20;

                html += `
                    <div class="disc-card ${isNarrow ? 'abnormal' : ''}">
                        <div class="disc-header">ğŸ’¿ ${level}</div>
                        <div class="disc-metrics">
                            <div class="disc-metric">å‰æ–¹: ${metrics.anteriorHeight.toFixed(1)} px</div>
                            <div class="disc-metric">å¾Œæ–¹: ${metrics.posteriorHeight.toFixed(1)} px</div>
                            <div class="disc-metric">å¹³å‡: ${metrics.middleHeight.toFixed(1)} px</div>
                            <div class="disc-metric">Wedge: ${metrics.wedgeAngle.toFixed(1)}Â°</div>
                        </div>
                    </div>`;
            }

            container.innerHTML = html || '<div style="color: #999; font-size: 12px; padding: 10px;">ç„¡æ³•è¨ˆç®—æ¤é–“ç›¤ï¼ˆç¼ºå°‘ç›¸é„°çµ‚æ¿ï¼‰</div>';
        }

        function updateAbnormalities() {
            const container = document.getElementById('abnormalities');
            const abnormalities = [];

            // 1. å£“è¿«æ€§éª¨æŠ˜
            vertebrae.forEach(v => {
                const abnType = !v.boundaryType && checkVertebraAbnormal(v);
                if (abnType === 'anteriorWedging') {
                    abnormalities.push({
                        type: 'danger',
                        title: `${v.name} Anterior Wedging Fracture`,
                        detail: `å‰ç·£/å¾Œç·£æ¯”ä¾‹: ${(v.anteriorHeight / v.posteriorHeight * 100).toFixed(0)}% (< 75%)`
                    });
                } else if (abnType === 'crushDeformity') {
                    abnormalities.push({
                        type: 'danger',
                        title: `${v.name} Crush Deformity Fracture`,
                        detail: `å‰ç·£/å¾Œç·£æ¯”ä¾‹: ${(v.anteriorHeight / v.posteriorHeight * 100).toFixed(0)}% (> 125%)`
                    });
                }
            });

            // 2. Listhesis
            checkListhesis().forEach(l => {
                abnormalities.push({
                    type: 'danger',
                    title: `${l.level} ${l.type}`,
                    detail: `å¾Œç·£åç§»: ${l.shift}%`
                });
            });

            // 3. é«˜åº¦éé€²
            checkHeightProgression().forEach(h => {
                abnormalities.push({ type: 'warning', title: h.level, detail: h.issue });
            });

            if (abnormalities.length === 0) {
                container.innerHTML = '<div style="color: #27ae60; font-size: 12px; padding: 10px;">âœ… æœªæª¢æ¸¬åˆ°æ˜é¡¯ç•°å¸¸</div>';
                return;
            }

            container.innerHTML = abnormalities.map(a => `
                <div class="abnormality-card ${a.type}">
                    <strong>âš ï¸ ${a.title}</strong><br>
                    <span style="font-size: 11px;">${a.detail}</span>
                </div>`).join('');
        }

        // ==================== åŒ¯å‡º ====================
        function exportData() {
            if (vertebrae.length === 0) { alert('è«‹å…ˆå®Œæˆæ¨™è¨»'); return; }

            const ordered = getAnatomicalOrder();

            // è¨ˆç®—æ¤é–“ç›¤
            const discData = [];
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;

                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                const upperLower = getLowerEndplate(ordered[i]);
                const lowerUpper = getUpperEndplate(ordered[i + 1]);

                discData.push({
                    level,
                    upperEndplate: upperLower,
                    lowerEndplate: lowerUpper,
                    anteriorHeight: metrics.anteriorHeight,
                    posteriorHeight: metrics.posteriorHeight,
                    middleHeight: metrics.middleHeight,
                    wedgeAngle: metrics.wedgeAngle
                });
            }

            const data = {
                version: "2.1",
                exportDate: new Date().toISOString(),
                spineType: spineType,
                imageInfo: originalImage ? {
                    width: originalImage.width,
                    height: originalImage.height
                } : null,
                vertebrae: ordered.map(v => {
                    const entry = {
                        name: v.name,
                        boundaryType: v.boundaryType || null
                    };
                    if (v.boundaryType === 'upper') {
                        entry.points = {
                            anteriorSuperior: v.points[0],
                            posteriorSuperior: v.points[1]
                        };
                    } else if (v.boundaryType === 'lower') {
                        entry.points = {
                            anteriorInferior: v.points[0],
                            posteriorInferior: v.points[1]
                        };
                    } else {
                        entry.points = {
                            anteriorSuperior: v.points[0],
                            posteriorSuperior: v.points[1],
                            posteriorInferior: v.points[2],
                            anteriorInferior: v.points[3]
                        };
                        entry.anteriorHeight = v.anteriorHeight;
                        entry.posteriorHeight = v.posteriorHeight;
                        const fractureType = checkVertebraAbnormal(v);
                        entry.anteriorWedgingFracture = fractureType === 'anteriorWedging';
                        entry.crushDeformityFracture = fractureType === 'crushDeformity';
                    }
                    return entry;
                }),
                discs: discData,
                abnormalities: {
                    compressionFractures: vertebrae
                        .filter(v => !v.boundaryType && checkVertebraAbnormal(v))
                        .map(v => ({
                            name: v.name,
                            type: checkVertebraAbnormal(v) // 'anteriorWedging' or 'crushDeformity'
                        })),
                    listhesis: checkListhesis(),
                    heightProgressionIssues: checkHeightProgression()
                }
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spine_annotation_${spineType}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportReport() {
            if (vertebrae.length === 0) { alert('è«‹å…ˆå®Œæˆæ¨™è¨»'); return; }

            const ordered = getAnatomicalOrder();
            let report = `è„Šæ¤æ¨™è¨»å ±å‘Š\n${'='.repeat(40)}\n\n`;
            report += `è„Šæ¤é¡å‹: ${spineType === 'L' ? 'è…°æ¤' : 'é ¸æ¤'}\n`;
            report += `æ¨™è¨»æ—¥æœŸ: ${new Date().toLocaleString('zh-TW')}\n\n`;

            report += `æ¤é«”åˆ†æ\n${'-'.repeat(30)}\n`;
            ordered.forEach(v => {
                if (v.boundaryType) {
                    report += `${v.name}: é‚Šç•Œæ¤é«” (${v.boundaryType === 'upper' ? 'ä¸Šçµ‚æ¿' : 'ä¸‹çµ‚æ¿'})\n`;
                } else {
                    const abnormal = checkVertebraAbnormal(v);
                    report += `${v.name}: å‰ç·£ ${v.anteriorHeight?.toFixed(1)}px / å¾Œç·£ ${v.posteriorHeight?.toFixed(1)}px`;
                    report += ` (${(v.anteriorHeight / v.posteriorHeight * 100).toFixed(0)}%)`;
                    if (abnormal === 'anteriorWedging') report += ` âš ï¸ Anterior Wedging Fracture`;
                    if (abnormal === 'crushDeformity') report += ` âš ï¸ Crush Deformity Fracture`;
                    report += `\n`;
                }
            });

            report += `\næ¤é–“ç›¤åˆ†æ\n${'-'.repeat(30)}\n`;
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;
                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                report += `${level}: é«˜åº¦ ${metrics.middleHeight.toFixed(1)}px, Wedge ${metrics.wedgeAngle.toFixed(1)}Â°\n`;
            }

            const listhesis = checkListhesis();
            if (listhesis.length > 0) {
                report += `\næ»‘è„«æª¢æ¸¬\n${'-'.repeat(30)}\n`;
                listhesis.forEach(l => {
                    report += `${l.level}: ${l.type} (${l.shift}%)\n`;
                });
            }

            navigator.clipboard.writeText(report).then(() => {
                alert('å ±å‘Šå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿');
            });
        }
    </script>
</body>
</html>
