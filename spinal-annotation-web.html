<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è„Šæ¤æ¤é«”æ¨™è¨»å·¥å…· V2.3 - Vertebra Annotation</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 { font-size: 24px; }
        .header-info { font-size: 13px; opacity: 0.9; }

        .spine-type-selector {
            display: flex;
            gap: 10px;
        }

        .spine-type-btn {
            padding: 10px 25px;
            border: 2px solid white;
            background: transparent;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .spine-type-btn.active {
            background: white;
            color: #16213e;
        }

        .spine-type-btn:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 380px;
            min-height: calc(100vh - 150px);
        }

        .image-section {
            padding: 15px;
            background: #f0f2f5;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        button:hover { transform: translateY(-1px); }

        .btn-primary { background: #3498db; color: white; }
        .btn-success { background: #27ae60; color: white; }
        .btn-warning { background: #f39c12; color: white; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-secondary { background: #95a5a6; color: white; }
        .btn-info { background: #9b59b6; color: white; }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2c3e50;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            cursor: crosshair;
        }

        .zoom-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .sidebar {
            background: white;
            padding: 15px;
            overflow-y: auto;
            border-left: 2px solid #e0e0e0;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: #ecf0f1;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }

        .progress-bar {
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .current-task {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .current-task strong { color: #856404; }

        .vertebra-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .vertebra-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: #e9ecef;
            cursor: pointer;
        }

        .vertebra-header:hover { background: #dee2e6; }

        .vertebra-name {
            font-weight: bold;
            color: #495057;
        }

        .vertebra-name select {
            font-weight: bold;
            font-size: 14px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 2px 5px;
            background: white;
        }

        .vertebra-status {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            background: #6c757d;
            color: white;
        }

        .vertebra-status.complete { background: #28a745; }
        .vertebra-status.current { background: #ffc107; color: #333; }
        .vertebra-status.warning { background: #dc3545; }

        .vertebra-body {
            padding: 10px 12px;
            font-size: 12px;
            display: none;
        }

        .vertebra-body.show { display: block; }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .metric-row:last-child { border-bottom: none; }

        .metric-label { color: #6c757d; }
        .metric-value { font-weight: 500; }
        .metric-value.danger { color: #dc3545; font-weight: bold; }
        .metric-value.warning { color: #f39c12; }
        .metric-value.success { color: #27ae60; }

        .disc-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 12px;
        }

        .disc-card.abnormal {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .disc-header {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .disc-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 11px;
        }

        .disc-metric {
            background: rgba(255,255,255,0.2);
            padding: 5px 8px;
            border-radius: 4px;
        }

        .abnormality-card {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-left: 4px solid #dc3545;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .abnormality-card.warning {
            background: #fff3cd;
            border-color: #ffc107;
            border-left-color: #f39c12;
        }

        .export-panel {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 15px;
            border-radius: 8px;
        }

        .export-panel button {
            width: 100%;
            margin-top: 8px;
            justify-content: center;
        }

        .help-text {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
        }

        .option-group {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 10px;
            font-size: 12px;
        }

        .option-group label {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            cursor: pointer;
        }

        .option-group label:last-child { margin-bottom: 0; }

        .point-guide {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
            font-size: 11px;
        }

        .point-item {
            padding: 5px;
            border-radius: 4px;
            text-align: center;
        }

        .point-item.active {
            font-weight: bold;
            box-shadow: 0 0 0 2px #333;
        }

        .point-1 { background: #ffcccc; }
        .point-2 { background: #ccffee; }
        .point-3 { background: #ccffcc; }
        .point-4 { background: #ccccff; }
        .point-5 { background: #ffe0cc; }
        .point-6 { background: #ffffcc; }

        @media (max-width: 1200px) {
            .main-content { grid-template-columns: 1fr; }
            .sidebar { border-left: none; border-top: 2px solid #e0e0e0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>ğŸ¦´ è„Šæ¤æ¤é«”æ¨™è¨»å·¥å…· V2.3</h1>
                <div class="header-info">æ¤é«”æ¨™è¨» 4/6 é»å¯åˆ‡æ›ï¼ˆçµ‚æ¿ 2/3 é»ï¼‰ï¼Œè‡ªå‹•è¨ˆç®—æ¤é–“ç›¤èˆ‡ç•°å¸¸</div>
            </div>
            <div class="spine-type-selector">
                <button class="spine-type-btn active" data-type="L" onclick="setSpineType('L')">
                    è…°æ¤ L-Spine
                </button>
                <button class="spine-type-btn" data-type="C" onclick="setSpineType('C')">
                    é ¸æ¤ C-Spine
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="image-section">
                <div class="toolbar">
                    <div class="toolbar-group">
                        <button class="btn-primary" onclick="loadImage()">ğŸ“‚ è¼‰å…¥å½±åƒ</button>
                        <button class="btn-primary" onclick="pasteImage()">ğŸ“‹ è²¼ä¸Š (Ctrl+V)</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="btn-warning" onclick="undoPoint()">â†¶ æ’¤éŠ·é»</button>
                        <button class="btn-danger" onclick="deleteCurrentVertebra()">ğŸ—‘ï¸ åˆªé™¤æ¤é«”</button>
                        <button class="btn-secondary" onclick="clearAll()">æ¸…é™¤å…¨éƒ¨</button>
                        <button class="btn-success" id="btnFinishEarly" onclick="finishEarly()" style="display:none;">âœ… çµæŸæ¨™è¨»</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="btn-info" onclick="toggleContrast()">ğŸ”† å°æ¯”å¢å¼·</button>
                        <button class="btn-secondary" onclick="zoomIn()">ğŸ”+</button>
                        <button class="btn-secondary" onclick="zoomOut()">ğŸ”-</button>
                        <button class="btn-secondary" onclick="resetZoom()">1:1</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="mainCanvas"></canvas>
                    <div class="zoom-info">ç¸®æ”¾: <span id="zoomLevel">100</span>%</div>
                </div>
            </div>

            <div class="sidebar">
                <!-- é€²åº¦ -->
                <div class="section">
                    <div class="progress-text">æ¨™è¨»é€²åº¦: <span id="progressCount">0</span> / <span id="totalCount">6</span> æ¤é«”</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- æ¨™è¨»æ¨¡å¼ -->
                <div class="section">
                    <div class="section-title">âš™ï¸ æ¨™è¨»è¨­å®š</div>
                    <div class="option-group">
                        <div style="font-weight: bold; margin-bottom: 6px;">çµ‚æ¿é»æ•¸</div>
                        <label>
                            <input type="radio" name="endplateMode" value="2" onchange="setEndplatePointMode(2)">
                            2 é»ï¼ˆV2.1ï¼‰
                        </label>
                        <label>
                            <input type="radio" name="endplateMode" value="3" onchange="setEndplatePointMode(3)" checked>
                            3 é»ï¼ˆå«ä¸­é»ï¼Œå¯è©•ä¼°é›™å‡¹å£“è¿«ï¼‰
                        </label>
                        <div class="help-text">åˆ‡æ›å¾Œéœ€é‡æ–°æ¨™è¨»ã€‚</div>
                    </div>
                </div>

                <!-- ç•¶å‰ä»»å‹™ -->
                <div class="current-task" id="currentTask">
                    <strong>ğŸ“ ä¸‹ä¸€æ­¥ï¼š</strong><span id="taskText">è«‹å…ˆè¼‰å…¥æˆ–è²¼ä¸Šå½±åƒ</span>
                    <div class="point-guide" id="pointGuide" style="display: none;">
                    </div>
                </div>

                <!-- æ¤é«”åˆ—è¡¨ -->
                <div class="section">
                    <div class="section-title">ğŸ“‹ æ¤é«”åˆ—è¡¨</div>
                    <div id="vertebraList"></div>
                </div>

                <!-- æ¤é–“ç›¤åˆ†æ -->
                <div class="section">
                    <div class="section-title">ğŸ’¿ æ¤é–“ç›¤åˆ†æ</div>
                    <div id="discAnalysis"></div>
                </div>

                <!-- ç•°å¸¸æª¢æ¸¬ -->
                <div class="section">
                    <div class="section-title">âš ï¸ ç•°å¸¸æª¢æ¸¬</div>
                    <div id="abnormalities"></div>
                </div>

                <!-- åŒ¯å‡º -->
                <div class="export-panel">
                    <strong>ğŸ’¾ åŒ¯å‡ºæ•¸æ“š</strong>
                    <div class="help-text">å®Œæˆæ¨™è¨»å¾ŒåŒ¯å‡ºè¨“ç·´æ•¸æ“š</div>
                    <button class="btn-success" onclick="exportData()">åŒ¯å‡º JSON</button>
                    <button class="btn-info" onclick="exportReport()">åŒ¯å‡ºå ±å‘Š</button>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="handleFileSelect(event)">

    <script>
        // ==================== é…ç½® ====================
        // æ¤é«”åˆ—è¡¨ï¼šæŒ‰è§£å‰–å­¸ç”±ä¸Šåˆ°ä¸‹æ’åˆ—
        // boundary æ¨™è¨˜é‚Šç•Œæ¤é«”ï¼š'upper' = åªæœ‰ä¸Šçµ‚æ¿ï¼Œ'lower' = åªæœ‰ä¸‹çµ‚æ¿
        const CONFIG = {
            L: {
                vertebrae: ['T12', 'L1', 'L2', 'L3', 'L4', 'L5', 'S1'],
                boundary: { 'T12': 'lower', 'S1': 'upper' },
                direction: 'bottom-up', // ç”±ä¸‹åˆ°ä¸Šæ¨™è¨»
                expectedHeightPattern: 'L4L5_highest',
            },
            C: {
                vertebrae: ['C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'T1'],
                boundary: { 'C2': 'lower', 'T1': 'upper' },
                direction: 'top-down', // ç”±ä¸Šåˆ°ä¸‹æ¨™è¨»
                expectedHeightPattern: 'increasing',
            }
        };

        const COLORS = {
            point1: '#ff6b6b', // å‰ä¸Šè§’ - ç´…
            point2: '#20c997', // ä¸Šçµ‚æ¿ä¸­é» - é’
            point3: '#51cf66', // å¾Œä¸Šè§’ - ç¶ 
            point4: '#339af0', // å¾Œä¸‹è§’ - è—
            point5: '#fd7e14', // ä¸‹çµ‚æ¿ä¸­é» - æ©™
            point6: '#fcc419', // å‰ä¸‹è§’ - é»ƒ
            line: '#ffffff',
            currentVertebra: '#00ff00',
            completedVertebra: '#3498db',
            abnormalVertebra: '#e74c3c',
            boundaryVertebra: '#9b59b6'
        };

        // ==================== ç‹€æ…‹ ====================
        let canvas, ctx;
        let originalImage = null;
        let spineType = 'L';
        let vertebrae = [];
        let currentPoints = [];
        let zoom = 1;
        let panX = 0, panY = 0;
        let isDragging = false;
        let wasDragging = false; // è¿½è¹¤æ˜¯å¦å¯¦éš›æ‹–æ›³éï¼ˆç”¨æ–¼æ±ºå®šæ˜¯å¦é˜»æ­¢å³éµé¸å–®ï¼‰
        let lastMousePos = {x: 0, y: 0};
        let contrastEnhanced = false;
        let processedImage = null;
        let annotationFinished = false; // æå‰çµæŸæ¨™è¨»
        let endplatePointMode = 3; // 2 or 3 points per endplate

        // ==================== è¼”åŠ©å‡½æ•¸ ====================
        function getNextVertebraName() {
            if (annotationFinished) return null;
            const config = CONFIG[spineType];
            const idx = vertebrae.length;
            if (idx >= config.vertebrae.length) return null;
            if (config.direction === 'bottom-up') {
                return config.vertebrae[config.vertebrae.length - 1 - idx];
            } else {
                return config.vertebrae[idx];
            }
        }

        function isBoundary(name) {
            const config = CONFIG[spineType];
            return config.boundary[name] || null;
        }

        function getRequiredPoints(name) {
            // é‚Šç•Œæ¤é«”éœ€ endplatePointMode é»ï¼Œå®Œæ•´æ¤é«”ç‚º 2 å€
            return isBoundary(name) ? endplatePointMode : endplatePointMode * 2;
        }

        function getPointLabelsForVertebra(name) {
            const b = isBoundary(name);
            if (endplatePointMode === 2) {
                if (b === 'upper') {
                    return ['å‰ä¸Šè§’', 'å¾Œä¸Šè§’'];
                } else if (b === 'lower') {
                    return ['å‰ä¸‹è§’', 'å¾Œä¸‹è§’'];
                }
                return ['å‰ä¸Šè§’', 'å¾Œä¸Šè§’', 'å¾Œä¸‹è§’', 'å‰ä¸‹è§’'];
            }

            if (b === 'upper') {
                // S1/T1: åªæœ‰ä¸Šçµ‚æ¿ â†’ å‰ä¸Šè§’, ä¸Šçµ‚æ¿ä¸­é», å¾Œä¸Šè§’
                return ['å‰ä¸Šè§’', 'ä¸Šçµ‚æ¿ä¸­é»', 'å¾Œä¸Šè§’'];
            } else if (b === 'lower') {
                // T12/C2: åªæœ‰ä¸‹çµ‚æ¿ â†’ å‰ä¸‹è§’, ä¸‹çµ‚æ¿ä¸­é», å¾Œä¸‹è§’
                return ['å‰ä¸‹è§’', 'ä¸‹çµ‚æ¿ä¸­é»', 'å¾Œä¸‹è§’'];
            }
            return ['å‰ä¸Šè§’', 'ä¸Šçµ‚æ¿ä¸­é»', 'å¾Œä¸Šè§’', 'å¾Œä¸‹è§’', 'ä¸‹çµ‚æ¿ä¸­é»', 'å‰ä¸‹è§’'];
        }

        // ==================== åˆå§‹åŒ– ====================
        window.onload = function() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            canvas.addEventListener('contextmenu', e => {
                // åªåœ¨æ‹–æ›³å¹³ç§»æ™‚é˜»æ­¢å³éµé¸å–®ï¼Œéœæ­¢å³éµå…è¨±ã€Œå¦å­˜åœ–ç‰‡ã€
                if (wasDragging) {
                    e.preventDefault();
                    wasDragging = false;
                }
            });
            document.addEventListener('paste', handlePaste);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);

            document.addEventListener('keydown', handleKeyDown);

            updateUI();
            updateEndplateModeUI();
        };

        // ==================== å½±åƒè™•ç† ====================
        function loadImage() {
            document.getElementById('fileInput').click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) loadImageFromFile(file);
        }

        function handlePaste(e) {
            e.preventDefault();
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    loadImageFromFile(item.getAsFile());
                    return;
                }
            }
        }

        function pasteImage() {
            navigator.clipboard.read().then(data => {
                for (let item of data) {
                    for (let type of item.types) {
                        if (type.startsWith('image/')) {
                            item.getType(type).then(blob => loadImageFromFile(blob));
                            return;
                        }
                    }
                }
                alert('å‰ªè²¼ç°¿ä¸­æ²’æœ‰åœ–ç‰‡');
            }).catch(() => alert('è«‹ä½¿ç”¨ Ctrl+V è²¼ä¸Š'));
        }

        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    resetZoom();
                    contrastEnhanced = false;
                    processedImage = null;
                    redraw();
                    updateUI();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function toggleContrast() {
            if (!originalImage) return;
            contrastEnhanced = !contrastEnhanced;

            if (contrastEnhanced && !processedImage) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = originalImage.width;
                tempCanvas.height = originalImage.height;
                tempCtx.drawImage(originalImage, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;

                let min = 255, max = 0;
                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                    min = Math.min(min, gray);
                    max = Math.max(max, gray);
                }

                const range = max - min || 1;
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        data[i+j] = Math.round(((data[i+j] - min) / range) * 255);
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);
                processedImage = new Image();
                processedImage.src = tempCanvas.toDataURL();
                processedImage.onload = () => redraw();
            } else {
                redraw();
            }
        }

        // ==================== ç¸®æ”¾å’Œå¹³ç§» ====================
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, zoom * delta));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            panX = mouseX - (mouseX - panX) * (newZoom / zoom);
            panY = mouseY - (mouseY - panY) * (newZoom / zoom);

            zoom = newZoom;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100);
            redraw();
        }

        function handleMouseDown(e) {
            if (e.button === 1 || e.button === 2) {
                isDragging = true;
                lastMousePos = {x: e.clientX, y: e.clientY};
                e.preventDefault();
            }
        }

        function handleMouseMove(e) {
            if (isDragging) {
                panX += e.clientX - lastMousePos.x;
                panY += e.clientY - lastMousePos.y;
                lastMousePos = {x: e.clientX, y: e.clientY};
                wasDragging = true;
                redraw();
            }
        }

        function handleMouseUp() {
            isDragging = false;
            // wasDragging ç”± contextmenu handler é‡ç½®ï¼Œä¸åœ¨æ­¤é‡ç½®
        }

        function zoomIn() { zoom = Math.min(5, zoom * 1.2); document.getElementById('zoomLevel').textContent = Math.round(zoom * 100); redraw(); }
        function zoomOut() { zoom = Math.max(0.1, zoom / 1.2); document.getElementById('zoomLevel').textContent = Math.round(zoom * 100); redraw(); }
        function resetZoom() { zoom = 1; panX = 0; panY = 0; document.getElementById('zoomLevel').textContent = '100'; redraw(); }

        // ==================== è„Šæ¤é¡å‹ ====================
        function setSpineType(type) {
            if (vertebrae.length > 0) {
                if (!confirm('åˆ‡æ›è„Šæ¤é¡å‹æœƒæ¸…é™¤ç¾æœ‰æ¨™è¨»ï¼Œç¢ºå®šå—ï¼Ÿ')) return;
                vertebrae = [];
                currentPoints = [];
                annotationFinished = false;
            }
            spineType = type;
            document.querySelectorAll('.spine-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            updateUI();
            redraw();
        }

        function setEndplatePointMode(mode) {
            if (endplatePointMode === mode) return;
            if (vertebrae.length > 0 || currentPoints.length > 0) {
                if (!confirm('åˆ‡æ›çµ‚æ¿é»æ•¸æœƒæ¸…é™¤ç¾æœ‰æ¨™è¨»ï¼Œç¢ºå®šå—ï¼Ÿ')) {
                    updateEndplateModeUI();
                    return;
                }
                vertebrae = [];
                currentPoints = [];
                annotationFinished = false;
            }
            endplatePointMode = mode;
            updateEndplateModeUI();
            updateUI();
            redraw();
        }

        function updateEndplateModeUI() {
            document.querySelectorAll('input[name="endplateMode"]').forEach(input => {
                input.checked = parseInt(input.value, 10) === endplatePointMode;
            });
        }

        // ==================== é»æ“Šè™•ç† ====================
        function handleCanvasClick(event) {
            if (!originalImage || isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            const x = (canvasX - panX) / zoom;
            const y = (canvasY - panY) / zoom;

            if (x < 0 || x > originalImage.width || y < 0 || y > originalImage.height) return;

            const nextName = getNextVertebraName();
            if (!nextName) {
                alert('å·²é”åˆ°æœ€å¤§æ¤é«”æ•¸é‡');
                return;
            }

            const requiredPts = getRequiredPoints(nextName);
            currentPoints.push({x, y});

            if (currentPoints.length === requiredPts) {
                const boundaryType = isBoundary(nextName);
                let sortedPoints;
                const hasMiddlePoints = endplatePointMode === 3;

                if (boundaryType === 'upper') {
                    // S1/T1: åªæœ‰ä¸Šçµ‚æ¿
                    sortedPoints = normalizeEndplate(currentPoints);
                } else if (boundaryType === 'lower') {
                    // T12/C2: åªæœ‰ä¸‹çµ‚æ¿
                    sortedPoints = normalizeEndplate(currentPoints);
                } else {
                    // å®Œæ•´æ¤é«”: 4/6 é»
                    sortedPoints = normalizePoints(currentPoints);
                }

                vertebrae.push({
                    name: nextName,
                    points: sortedPoints,
                    boundaryType: boundaryType,
                    anteriorHeight: null,
                    posteriorHeight: null,
                    hasMiddlePoints: hasMiddlePoints
                });

                calculateVertebraMetrics(vertebrae.length - 1);
                currentPoints = [];
            }

            redraw();
            updateUI();
        }

        function midpoint(p1, p2) {
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function normalizeEndplate(points) {
            // 2 æˆ– 3 é»: x æ’åº â†’ [anterior(æœ€å°x), middle(ä¸­é–“x), posterior(æœ€å¤§x)]
            const sorted = [...points].sort((a, b) => a.x - b.x);
            if (sorted.length === 2) {
                const mid = midpoint(sorted[0], sorted[1]);
                return [sorted[0], mid, sorted[1]];
            }
            return [sorted[0], sorted[1], sorted[2]];
        }

        function normalizePoints(points) {
            // 4 æˆ– 6 é»: ç”¢å‡º [å‰ä¸Š, ä¸Šä¸­, å¾Œä¸Š, å¾Œä¸‹, ä¸‹ä¸­, å‰ä¸‹]
            const sorted = [...points].sort((a, b) => a.y - b.y);
            const half = sorted.length / 2;
            const topPoints = sorted.slice(0, half);
            const bottomPoints = sorted.slice(half);

            topPoints.sort((a, b) => a.x - b.x);
            bottomPoints.sort((a, b) => a.x - b.x);

            if (points.length === 4) {
                const anteriorSuperior = topPoints[0];
                const posteriorSuperior = topPoints[1];
                const anteriorInferior = bottomPoints[0];
                const posteriorInferior = bottomPoints[1];
                const middleSuperior = midpoint(anteriorSuperior, posteriorSuperior);
                const middleInferior = midpoint(anteriorInferior, posteriorInferior);
                return [
                    anteriorSuperior,
                    middleSuperior,
                    posteriorSuperior,
                    posteriorInferior,
                    middleInferior,
                    anteriorInferior
                ];
            }

            return [
                topPoints[0],     // 0: å‰ä¸Šè§’ (anterior-superior)
                topPoints[1],     // 1: ä¸Šçµ‚æ¿ä¸­é» (middle-superior)
                topPoints[2],     // 2: å¾Œä¸Šè§’ (posterior-superior)
                bottomPoints[2],  // 3: å¾Œä¸‹è§’ (posterior-inferior)
                bottomPoints[1],  // 4: ä¸‹çµ‚æ¿ä¸­é» (middle-inferior)
                bottomPoints[0]   // 5: å‰ä¸‹è§’ (anterior-inferior)
            ];
        }

        function calculateVertebraMetrics(index) {
            const v = vertebrae[index];
            if (v.boundaryType) {
                // é‚Šç•Œæ¤é«”åªæœ‰ä¸€æ¢çµ‚æ¿ï¼Œç„¡æ³•è¨ˆç®—å‰å¾Œç·£é«˜åº¦
                v.anteriorHeight = null;
                v.posteriorHeight = null;
                v.middleHeight = null;
                return;
            }
            const pts = v.points;
            // pts: [0:AS, 1:MS, 2:PS, 3:PI, 4:MI, 5:AI]
            v.anteriorHeight = Math.sqrt(
                Math.pow(pts[5].x - pts[0].x, 2) + Math.pow(pts[5].y - pts[0].y, 2)
            );
            v.posteriorHeight = Math.sqrt(
                Math.pow(pts[3].x - pts[2].x, 2) + Math.pow(pts[3].y - pts[2].y, 2)
            );
            v.middleHeight = Math.sqrt(
                Math.pow(pts[4].x - pts[1].x, 2) + Math.pow(pts[4].y - pts[1].y, 2)
            );
        }

        // ==================== å–å¾—çµ‚æ¿åº§æ¨™ï¼ˆçµ±ä¸€ä»‹é¢ï¼‰====================
        function getUpperEndplate(v) {
            // å–å¾—æ¤é«”ä¸Šçµ‚æ¿çš„ [anterior, middle, posterior] åº§æ¨™
            if (v.boundaryType === 'upper') {
                // S1/T1: åªæœ‰ä¸Šçµ‚æ¿ [å‰ä¸Š, ä¸Šä¸­, å¾Œä¸Š]
                return [v.points[0], v.points[1], v.points[2]];
            } else if (v.boundaryType === 'lower') {
                // T12/C2: æ²’æœ‰ä¸Šçµ‚æ¿
                return null;
            }
            // å®Œæ•´æ¤é«”: [å‰ä¸Š, ä¸Šä¸­, å¾Œä¸Š]
            return [v.points[0], v.points[1], v.points[2]];
        }

        function getLowerEndplate(v) {
            // å–å¾—æ¤é«”ä¸‹çµ‚æ¿çš„ [anterior, middle, posterior] åº§æ¨™
            if (v.boundaryType === 'lower') {
                // T12/C2: åªæœ‰ä¸‹çµ‚æ¿ [å‰ä¸‹, ä¸‹ä¸­, å¾Œä¸‹]
                return [v.points[0], v.points[1], v.points[2]];
            } else if (v.boundaryType === 'upper') {
                // S1/T1: æ²’æœ‰ä¸‹çµ‚æ¿
                return null;
            }
            // å®Œæ•´æ¤é«”: [å‰ä¸‹, ä¸‹ä¸­, å¾Œä¸‹]
            return [v.points[5], v.points[4], v.points[3]];
        }

        function getPosteriorPoints(v) {
            // å–å¾—å¾Œç·£çš„ [ä¸Š, ä¸‹] åº§æ¨™ï¼Œç”¨æ–¼æ»‘è„«æª¢æ¸¬
            if (v.boundaryType === 'upper') {
                // S1/T1: åªæœ‰ä¸Šçµ‚æ¿ï¼Œå¾Œç·£ä¸Šé» = posterior-superior
                return { top: v.points[2], bottom: null };
            } else if (v.boundaryType === 'lower') {
                // T12/C2: åªæœ‰ä¸‹çµ‚æ¿ï¼Œå¾Œç·£ä¸‹é» = posterior-inferior
                return { top: null, bottom: v.points[2] };
            }
            // pts: [0:AS, 1:MS, 2:PS, 3:PI, 4:MI, 5:AI]
            return { top: v.points[2], bottom: v.points[3] };
        }

        // ==================== å¿«æ·éµ ====================
        function handleKeyDown(e) {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undoPoint();
            }
        }

        function undoPoint() {
            if (currentPoints.length > 0) {
                currentPoints.pop();
            } else if (vertebrae.length > 0) {
                vertebrae.pop();
                annotationFinished = false; // æ’¤éŠ·å¾Œå¯ç¹¼çºŒæ¨™è¨»
            }
            redraw();
            updateUI();
        }

        function deleteCurrentVertebra() {
            if (currentPoints.length > 0) {
                currentPoints = [];
            } else if (vertebrae.length > 0) {
                vertebrae.pop();
                annotationFinished = false; // åˆªé™¤æ¤é«”å¾Œå¯ç¹¼çºŒæ¨™è¨»
            }
            redraw();
            updateUI();
        }

        function clearAll() {
            if (confirm('ç¢ºå®šæ¸…é™¤æ‰€æœ‰æ¨™è¨»ï¼Ÿ')) {
                vertebrae = [];
                currentPoints = [];
                annotationFinished = false;
                redraw();
                updateUI();
            }
        }

        function finishEarly() {
            if (vertebrae.length < 2) {
                alert('è‡³å°‘éœ€è¦æ¨™è¨» 2 å€‹æ¤é«”æ‰èƒ½çµæŸ');
                return;
            }
            if (currentPoints.length > 0) {
                if (!confirm('ç›®å‰æœ‰æœªå®Œæˆçš„æ¨™è¨»é»ï¼Œç¢ºå®šè¦æ¨æ£„ä¸¦çµæŸå—ï¼Ÿ')) return;
                currentPoints = [];
            }
            annotationFinished = true;
            redraw();
            updateUI();
        }

        // ==================== ç¹ªè£½ ====================
        function redraw() {
            if (!originalImage) {
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('è«‹è¼‰å…¥æˆ–è²¼ä¸Šè„Šæ¤ X å…‰å½±åƒ', canvas.width/2, canvas.height/2);
                return;
            }

            ctx.save();
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            const img = (contrastEnhanced && processedImage) ? processedImage : originalImage;
            ctx.drawImage(img, 0, 0);

            // ç¹ªè£½å·²å®Œæˆçš„æ¤é«”
            vertebrae.forEach((v, idx) => {
                const isAbnormal = !v.boundaryType && (checkVertebraAbnormal(v) || checkBiconcaveCompression(v));
                const color = v.boundaryType ? COLORS.boundaryVertebra :
                              isAbnormal ? COLORS.abnormalVertebra : COLORS.completedVertebra;
                drawVertebra(v, color, idx);
            });

            // ç¹ªè£½ç•¶å‰é»
            const nextName = getNextVertebraName();
            const labels = nextName ? getPointLabelsForVertebra(nextName) : [];
            currentPoints.forEach((p, idx) => {
                const colors = [COLORS.point1, COLORS.point2, COLORS.point3, COLORS.point4, COLORS.point5, COLORS.point6];
                drawPoint(p, colors[idx], idx + 1);
                if (idx > 0) drawLine(currentPoints[idx-1], p, '#ffffff', 2);
            });

            // é è¦½é–‰åˆç·š
            const reqPts = nextName ? getRequiredPoints(nextName) : endplatePointMode * 2;
            if (currentPoints.length === reqPts - 1 && reqPts === endplatePointMode * 2) {
                ctx.setLineDash([5, 5]);
                drawLine(currentPoints[currentPoints.length - 1], currentPoints[0], '#ffffff', 1);
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        function drawVertebra(v, color, index) {
            const pts = v.points;

            if (v.boundaryType) {
                // é‚Šç•Œæ¤é«”ï¼šç•« 3 é»çµ‚æ¿æŠ˜ç·šï¼ˆanterior â†’ middle â†’ posteriorï¼‰
                ctx.strokeStyle = color;
                ctx.lineWidth = 3 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[1].x, pts[1].y);
                ctx.lineTo(pts[2].x, pts[2].y);
                ctx.stroke();

                // æ¨™è¨˜ç«¯é»
                drawPoint(pts[0], COLORS.point1, null, 5 / zoom); // å‰
                drawPoint(pts[1], COLORS.point2, null, 5 / zoom); // ä¸­
                drawPoint(pts[2], COLORS.point3, null, 5 / zoom); // å¾Œ

                // æ¨™ç±¤
                const cx = pts[1].x;
                const cy = pts[1].y;
                const offset = v.boundaryType === 'upper' ? -20 : 20;
                drawLabel(v.name, cx, cy + offset / zoom);
            } else {
                // å®Œæ•´æ¤é«” 4/6 é»: [0:AS, 1:MS, 2:PS, 3:PI, 4:MI, 5:AI]
                // ç¹ªè£½å¡«å……å¤šé‚Šå½¢
                ctx.fillStyle = color + '30';
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[1].x, pts[1].y);
                ctx.lineTo(pts[2].x, pts[2].y);
                ctx.lineTo(pts[3].x, pts[3].y);
                ctx.lineTo(pts[4].x, pts[4].y);
                ctx.lineTo(pts[5].x, pts[5].y);
                ctx.closePath();
                ctx.fill();

                // ç¹ªè£½è¼ªå»“
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[1].x, pts[1].y);
                ctx.lineTo(pts[2].x, pts[2].y);
                ctx.lineTo(pts[3].x, pts[3].y);
                ctx.lineTo(pts[4].x, pts[4].y);
                ctx.lineTo(pts[5].x, pts[5].y);
                ctx.closePath();
                ctx.stroke();

                // ä¸Šçµ‚æ¿ï¼ˆç´…è‰²æŠ˜ç·šï¼‰: AS â†’ MS â†’ PS
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 3 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[1].x, pts[1].y);
                ctx.lineTo(pts[2].x, pts[2].y);
                ctx.stroke();

                // ä¸‹çµ‚æ¿ï¼ˆè—è‰²æŠ˜ç·šï¼‰: AI â†’ MI â†’ PI
                ctx.strokeStyle = '#339af0';
                ctx.beginPath();
                ctx.moveTo(pts[5].x, pts[5].y);
                ctx.lineTo(pts[4].x, pts[4].y);
                ctx.lineTo(pts[3].x, pts[3].y);
                ctx.stroke();

                // å‰ç·£: AS â†’ AI
                ctx.strokeStyle = '#ff6b6b80';
                ctx.lineWidth = 2 / zoom;
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                ctx.lineTo(pts[5].x, pts[5].y);
                ctx.stroke();

                // å¾Œç·£: PS â†’ PI
                ctx.strokeStyle = '#339af080';
                ctx.beginPath();
                ctx.moveTo(pts[2].x, pts[2].y);
                ctx.lineTo(pts[3].x, pts[3].y);
                ctx.stroke();

                // ç¹ªè£½å„è§’é»
                const colors = [COLORS.point1, COLORS.point2, COLORS.point3, COLORS.point4, COLORS.point5, COLORS.point6];
                pts.forEach((p, i) => {
                    drawPoint(p, colors[i], null, 4 / zoom);
                });

                // æ¨™ç±¤æ”¾åœ¨æ¤é«”ä¸­å¿ƒ
                const centerX = (pts[0].x + pts[3].x) / 2;
                const centerY = (pts[0].y + pts[3].y) / 2;
                drawLabel(v.name, centerX, centerY);
            }
        }

        function drawLabel(text, x, y) {
            const fontSize = Math.max(12, 16 / zoom);
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const textWidth = ctx.measureText(text).width;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(x - textWidth/2 - 4, y - fontSize/2 - 2, textWidth + 8, fontSize + 4);
            ctx.fillStyle = '#fff';
            ctx.fillText(text, x, y);
        }

        function drawPoint(p, color, label, radius = 6) {
            const r = (typeof radius === 'number' ? radius : 6) / (radius > 1 ? 1 : zoom);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5 / zoom;
            ctx.stroke();

            if (label) {
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${10/zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label.toString(), p.x, p.y);
            }
        }

        function drawLine(p1, p2, color, width) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width / zoom;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // ==================== åˆ†æè¨ˆç®— ====================
        function checkVertebraAbnormal(v) {
            // å›å‚³ç•°å¸¸é¡å‹: false / 'anteriorWedging' / 'crushDeformity'
            if (!v.anteriorHeight || !v.posteriorHeight) return false;
            if (v.anteriorHeight < v.posteriorHeight * 0.75) return 'anteriorWedging';
            if (v.anteriorHeight > v.posteriorHeight * 1.25) return 'crushDeformity';
            return false;
        }

        function checkBiconcaveCompression(v) {
            if (!v.hasMiddlePoints) return false;
            if (!v.middleHeight || !v.anteriorHeight || !v.posteriorHeight) return false;
            const avgSide = (v.anteriorHeight + v.posteriorHeight) / 2;
            return v.middleHeight < avgSide * 0.75;
        }

        function getAnatomicalOrder() {
            // å°‡æ¤é«”æŒ‰è§£å‰–å­¸ç”±ä¸Šåˆ°ä¸‹æ’åˆ—
            const config = CONFIG[spineType];
            const order = config.vertebrae;
            return [...vertebrae].sort((a, b) => order.indexOf(a.name) - order.indexOf(b.name));
        }

        function getDiscLevel(upperName, lowerName) {
            // æ°¸é æŒ‰è§£å‰–å­¸é †åºå‘½åï¼šä¸Šæ¤é«”/ä¸‹æ¤é«”
            const config = CONFIG[spineType];
            const order = config.vertebrae;
            const iUpper = order.indexOf(upperName);
            const iLower = order.indexOf(lowerName);
            if (iUpper < iLower) return `${upperName}/${lowerName}`;
            return `${lowerName}/${upperName}`;
        }

        function calculateDiscMetrics(upperV, lowerV) {
            // ä¸Šæ¤é«”çš„ä¸‹çµ‚æ¿ vs ä¸‹æ¤é«”çš„ä¸Šçµ‚æ¿
            const upperLower = getLowerEndplate(upperV); // [anterior, middle, posterior]
            const lowerUpper = getUpperEndplate(lowerV); // [anterior, middle, posterior]

            if (!upperLower || !lowerUpper) return null;

            const anteriorHeight = Math.sqrt(
                Math.pow(lowerUpper[0].x - upperLower[0].x, 2) +
                Math.pow(lowerUpper[0].y - upperLower[0].y, 2)
            );

            const posteriorHeight = Math.sqrt(
                Math.pow(lowerUpper[2].x - upperLower[2].x, 2) +
                Math.pow(lowerUpper[2].y - upperLower[2].y, 2)
            );

            // ä½¿ç”¨å¯¦éš›ä¸­é»è·é›¢ï¼Œè€Œéå¹³å‡å€¼ï¼Œé¿å…å‡¹é™·çµ‚æ¿é€ æˆé‡è¤‡
            const middleHeight = Math.sqrt(
                Math.pow(lowerUpper[1].x - upperLower[1].x, 2) +
                Math.pow(lowerUpper[1].y - upperLower[1].y, 2)
            );

            const upperAngle = Math.atan2(
                upperLower[2].y - upperLower[0].y,
                upperLower[2].x - upperLower[0].x
            );
            const lowerAngle = Math.atan2(
                lowerUpper[2].y - lowerUpper[0].y,
                lowerUpper[2].x - lowerUpper[0].x
            );
            let wedgeAngle = Math.abs(upperAngle - lowerAngle) * 180 / Math.PI;
            if (wedgeAngle > 90) wedgeAngle = 180 - wedgeAngle;

            const overlap = checkDiscOverlap(upperLower, lowerUpper);

            return { anteriorHeight, posteriorHeight, middleHeight, wedgeAngle, overlap };
        }

        function checkDiscOverlap(upperLower, lowerUpper) {
            const comparisons = upperLower.map((point, i) => ({
                upper: point,
                lower: lowerUpper[i]
            }));
            return comparisons.some(pair => pair.lower.y < pair.upper.y - 1);
        }

        function checkListhesis() {
            const results = [];
            const ordered = getAnatomicalOrder();
            // åªå–æœ‰å¾Œç·£è³‡è¨Šçš„æ¤é«”
            const withPosterior = ordered.filter(v => {
                const p = getPosteriorPoints(v);
                return p.top || p.bottom;
            });

            if (withPosterior.length < 3) return results;

            // å–å¾Œç·£ä»£è¡¨é»ï¼šå®Œæ•´æ¤é«”ç”¨ä¸­é»ï¼Œé‚Šç•Œæ¤é«”ç”¨æœ‰çš„é‚£å€‹é»
            const posteriorPts = withPosterior.map(v => {
                const p = getPosteriorPoints(v);
                let x, y;
                if (p.top && p.bottom) {
                    x = (p.top.x + p.bottom.x) / 2;
                    y = (p.top.y + p.bottom.y) / 2;
                } else if (p.top) {
                    x = p.top.x; y = p.top.y;
                } else {
                    x = p.bottom.x; y = p.bottom.y;
                }
                return { name: v.name, x, y, v };
            });

            const first = posteriorPts[0];
            const last = posteriorPts[posteriorPts.length - 1];
            const lineLen = Math.sqrt(Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2));
            if (lineLen === 0) return results;

            for (let i = 1; i < posteriorPts.length - 1; i++) {
                const p = posteriorPts[i];
                const distance = Math.abs(
                    (last.y - first.y) * p.x - (last.x - first.x) * p.y +
                    last.x * first.y - last.y * first.x
                ) / lineLen;

                // ä½¿ç”¨ä¸Šçµ‚æ¿å¯¬åº¦ä½œç‚ºåƒè€ƒ
                const upper = getUpperEndplate(p.v);
                if (!upper) continue;
                const width = Math.abs(upper[2].x - upper[0].x);
                if (width === 0) continue;

                const shiftPercent = (distance / width) * 100;

                if (shiftPercent > 5) {
                    const dy = last.y - first.y;
                    const expectedX = dy !== 0 ?
                        first.x + (p.y - first.y) * (last.x - first.x) / dy :
                        first.x;
                    const type = p.x > expectedX ? 'Retrolisthesis' : 'Anterolisthesis';

                    results.push({
                        level: p.name,
                        type: type,
                        shift: shiftPercent.toFixed(1)
                    });
                }
            }
            return results;
        }

        function checkHeightProgression() {
            const results = [];
            const ordered = getAnatomicalOrder();
            const discHeights = [];

            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;
                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                discHeights.push({ level, height: metrics.middleHeight });
            }

            if (discHeights.length < 2) return results;

            const config = CONFIG[spineType];

            if (config.expectedHeightPattern === 'L4L5_highest') {
                const l45 = discHeights.find(d => d.level === 'L4/L5');

                if (l45) {
                    discHeights.forEach(d => {
                        if (d.level !== 'L4/L5' && d.level !== 'L5/S1') {
                            if (d.height > l45.height * 1.1) {
                                results.push({
                                    level: d.level,
                                    issue: `æ¤é–“ç›¤é«˜åº¦ç•°å¸¸åé«˜ï¼ˆé«˜æ–¼ L4/L5ï¼‰`,
                                    severity: 'warning'
                                });
                            }
                        }
                    });
                }

                for (let i = 0; i < discHeights.length - 1; i++) {
                    if (discHeights[i + 1].level === 'L5/S1') continue;
                    if (discHeights[i].height > discHeights[i + 1].height * 1.3) {
                        results.push({
                            level: discHeights[i].level,
                            issue: `æ¤é–“ç›¤é«˜åº¦éé€²ç•°å¸¸`,
                            severity: 'warning'
                        });
                    }
                }
            } else if (config.expectedHeightPattern === 'increasing') {
                for (let i = 0; i < discHeights.length - 1; i++) {
                    if (discHeights[i].height > discHeights[i + 1].height * 1.2) {
                        results.push({
                            level: discHeights[i].level,
                            issue: `æ¤é–“ç›¤é«˜åº¦éé€²ç•°å¸¸ï¼ˆæ‡‰è¶Šä¾†è¶Šé«˜ï¼‰`,
                            severity: 'warning'
                        });
                    }
                }
            }
            return results;
        }

        // ==================== UI æ›´æ–° ====================
        function updateUI() {
            const config = CONFIG[spineType];
            const total = config.vertebrae.length;
            const completed = vertebrae.length;

            document.getElementById('progressCount').textContent = completed;
            document.getElementById('totalCount').textContent = total;
            document.getElementById('progressFill').style.width = `${(completed / total) * 100}%`;

            // é¡¯ç¤º/éš±è—ã€ŒçµæŸæ¨™è¨»ã€æŒ‰éˆ•ï¼šè‡³å°‘ 2 å€‹æ¤é«”ä¸”å°šæœªçµæŸ
            const btnFinish = document.getElementById('btnFinishEarly');
            if (btnFinish) {
                btnFinish.style.display = (completed >= 2 && !annotationFinished && completed < total) ? '' : 'none';
            }

            updateCurrentTask();
            updateVertebraList();
            updateDiscAnalysis();
            updateAbnormalities();
        }

        function updateCurrentTask() {
            const taskText = document.getElementById('taskText');
            const pointGuide = document.getElementById('pointGuide');

            if (!originalImage) {
                taskText.textContent = 'è«‹å…ˆè¼‰å…¥æˆ–è²¼ä¸Šå½±åƒ';
                pointGuide.style.display = 'none';
                return;
            }

            const nextName = getNextVertebraName();
            if (!nextName) {
                taskText.textContent = 'âœ… æ¨™è¨»å®Œæˆï¼å¯ä»¥åŒ¯å‡ºæ•¸æ“š';
                pointGuide.style.display = 'none';
                return;
            }

            const required = getRequiredPoints(nextName);
            const labels = getPointLabelsForVertebra(nextName);
            const bType = isBoundary(nextName);
            const bHint = bType === 'upper' ? '(ä¸Šçµ‚æ¿)' :
                          bType === 'lower' ? '(ä¸‹çµ‚æ¿)' : '';

            taskText.textContent = `æ¨™è¨» ${nextName} ${bHint} (${currentPoints.length}/${required} é»)`;
            pointGuide.style.display = 'grid';
            pointGuide.style.gridTemplateColumns = `repeat(${Math.min(labels.length, 3)}, 1fr)`;

            // æ›´æ–°é»å¼•å° â€” å‹•æ…‹é¡¯ç¤º
            const guideContainer = document.getElementById('pointGuide');
            let guideHtml = '';
            labels.forEach((label, i) => {
                const isActive = i === currentPoints.length;
                const colorClasses = ['point-1', 'point-2', 'point-3', 'point-4', 'point-5', 'point-6'];
                guideHtml += `<div class="point-item ${colorClasses[i]} ${isActive ? 'active' : ''}">
                    ${i + 1} ${label}
                </div>`;
            });
            guideContainer.innerHTML = guideHtml;
        }

        function updateVertebraList() {
            const list = document.getElementById('vertebraList');
            const config = CONFIG[spineType];

            if (vertebrae.length === 0) {
                list.innerHTML = '<div style="color: #999; font-size: 12px; padding: 10px;">å°šæœªæ¨™è¨»æ¤é«”</div>';
                return;
            }

            let html = '';
            vertebrae.forEach((v, idx) => {
                const abnormalType = !v.boundaryType && checkVertebraAbnormal(v);
                const biconcave = !v.boundaryType && checkBiconcaveCompression(v);
                const isBound = !!v.boundaryType;
                const statusClass = (abnormalType || biconcave) ? 'warning' : 'complete';
                const abnormalLabel = abnormalType === 'anteriorWedging' ? 'âš ï¸ å‰ç·£å£“è¿«' :
                                     abnormalType === 'crushDeformity' ? 'âš ï¸ Crush' : '';
                const statusText = isBound ? (v.boundaryType === 'upper' ? 'ä¸Šçµ‚æ¿' : 'ä¸‹çµ‚æ¿') :
                                   abnormalType ? abnormalLabel :
                                   biconcave ? 'âš ï¸ é›™å‡¹å£“è¿«' : 'âœ“ å®Œæˆ';

                // é¸å–®åŒ…å«æ‰€æœ‰æ¤é«”åç¨±
                const allNames = config.vertebrae;

                html += `
                    <div class="vertebra-card">
                        <div class="vertebra-header" onclick="toggleVertebraBody(${idx})">
                            <div class="vertebra-name">
                                <select onchange="changeVertebraName(${idx}, this.value)" onclick="event.stopPropagation()">
                                    ${allNames.map(name =>
                                        `<option value="${name}" ${v.name === name ? 'selected' : ''}>${name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <span class="vertebra-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="vertebra-body" id="vertebra-body-${idx}">`;

                if (!isBound) {
                    html += `
                            <div class="metric-row">
                                <span class="metric-label">å‰ç·£é«˜åº¦:</span>
                                <span class="metric-value">${v.anteriorHeight?.toFixed(1) || '-'} px</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">ä¸­é–“é«˜åº¦:</span>
                                <span class="metric-value">${v.middleHeight?.toFixed(1) || '-'} px</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">å¾Œç·£é«˜åº¦:</span>
                                <span class="metric-value">${v.posteriorHeight?.toFixed(1) || '-'} px</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">å‰/å¾Œæ¯”ä¾‹:</span>
                                <span class="metric-value ${abnormalType ? 'danger' : ''}">${v.anteriorHeight && v.posteriorHeight ? (v.anteriorHeight / v.posteriorHeight * 100).toFixed(0) + '%' : '-'}</span>
                            </div>
                            ${abnormalType === 'anteriorWedging' ? '<div style="color: #dc3545; font-size: 11px; margin-top: 5px;">âš ï¸ ç–‘ä¼¼å‰ç·£å£“è¿«æ€§éª¨æŠ˜ (Anterior Wedging)</div>' : ''}
                            ${abnormalType === 'crushDeformity' ? '<div style="color: #dc3545; font-size: 11px; margin-top: 5px;">âš ï¸ ç–‘ä¼¼ Crush Deformity Compression Fracture</div>' : ''}`;
                    if (biconcave) {
                        html += '<div style="color: #dc3545; font-size: 11px; margin-top: 5px;">âš ï¸ ç–‘ä¼¼é›™å‡¹å£“è¿«æ€§éª¨æŠ˜ (Biconcave)</div>';
                    }
                    if (!v.hasMiddlePoints) {
                        html += '<div style="color: #6c757d; font-size: 11px; margin-top: 5px;">ä¸­é»é«˜åº¦ç‚ºæ¨ä¼°å€¼ï¼ˆæœªæ¨™è¨»ä¸­é»ï¼‰</div>';
                    }
                } else {
                    html += `<div style="color: #6c757d; font-size: 11px;">é‚Šç•Œæ¤é«” â€” åƒ…æ¨™è¨˜${v.boundaryType === 'upper' ? 'ä¸Š' : 'ä¸‹'}çµ‚æ¿</div>`;
                }

                html += `</div></div>`;
            });

            list.innerHTML = html;
        }

        function toggleVertebraBody(idx) {
            document.getElementById(`vertebra-body-${idx}`).classList.toggle('show');
        }

        function changeVertebraName(idx, newName) {
            const oldBoundary = isBoundary(vertebrae[idx].name);
            const newBoundary = isBoundary(newName);

            // å¦‚æœé‚Šç•Œé¡å‹æ”¹è®Šï¼ˆé»æ•¸ä¸åŒï¼‰ï¼Œæé†’ä½¿ç”¨è€…
            if (oldBoundary !== newBoundary) {
                const fullPoints = endplatePointMode * 2;
                const boundaryPoints = endplatePointMode;
                alert(`æ³¨æ„ï¼š${newName} ${newBoundary ? 'æ˜¯é‚Šç•Œæ¤é«”ï¼ˆ' + (newBoundary === 'upper' ? 'ä¸Šçµ‚æ¿' : 'ä¸‹çµ‚æ¿') + 'ï¼‰' : 'æ˜¯å®Œæ•´æ¤é«”ï¼ˆ' + fullPoints + 'é»ï¼‰'}ã€‚\né»æ•¸ä¸åŒ¹é…ï¼ˆé‚Šç•Œéœ€ ${boundaryPoints} é»ï¼‰ï¼Œå»ºè­°åˆªé™¤å¾Œé‡æ–°æ¨™è¨»ã€‚`);
            }

            vertebrae[idx].name = newName;
            vertebrae[idx].boundaryType = newBoundary;
            updateUI();
            redraw();
        }

        function updateDiscAnalysis() {
            const container = document.getElementById('discAnalysis');
            const ordered = getAnatomicalOrder();

            if (ordered.length < 2) {
                container.innerHTML = '<div style="color: #999; font-size: 12px; padding: 10px;">éœ€è¦è‡³å°‘ 2 å€‹æ¤é«”æ‰èƒ½åˆ†ææ¤é–“ç›¤</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;

                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                const isNarrow = metrics.middleHeight < 20;
                const isOverlap = metrics.overlap;
                const isAbnormal = isNarrow || isOverlap;

                html += `
                    <div class="disc-card ${isAbnormal ? 'abnormal' : ''}">
                        <div class="disc-header">ğŸ’¿ ${level}</div>
                        <div class="disc-metrics">
                            <div class="disc-metric">å‰æ–¹: ${metrics.anteriorHeight.toFixed(1)} px</div>
                            <div class="disc-metric">å¾Œæ–¹: ${metrics.posteriorHeight.toFixed(1)} px</div>
                            <div class="disc-metric">å¹³å‡: ${metrics.middleHeight.toFixed(1)} px</div>
                            <div class="disc-metric">Wedge: ${metrics.wedgeAngle.toFixed(1)}Â°</div>
                            ${isOverlap ? '<div class="disc-metric">âš ï¸ çµ‚æ¿é‡ç–Š (Disc narrowing)</div>' : ''}
                        </div>
                    </div>`;
            }

            container.innerHTML = html || '<div style="color: #999; font-size: 12px; padding: 10px;">ç„¡æ³•è¨ˆç®—æ¤é–“ç›¤ï¼ˆç¼ºå°‘ç›¸é„°çµ‚æ¿ï¼‰</div>';
        }

        function updateAbnormalities() {
            const container = document.getElementById('abnormalities');
            const abnormalities = [];

            // 1. å£“è¿«æ€§éª¨æŠ˜
            vertebrae.forEach(v => {
                const abnType = !v.boundaryType && checkVertebraAbnormal(v);
                const biconcave = !v.boundaryType && checkBiconcaveCompression(v);
                if (abnType === 'anteriorWedging') {
                    abnormalities.push({
                        type: 'danger',
                        title: `${v.name} Anterior Wedging Fracture`,
                        detail: `å‰ç·£/å¾Œç·£æ¯”ä¾‹: ${(v.anteriorHeight / v.posteriorHeight * 100).toFixed(0)}% (< 75%)`
                    });
                } else if (abnType === 'crushDeformity') {
                    abnormalities.push({
                        type: 'danger',
                        title: `${v.name} Crush Deformity Fracture`,
                        detail: `å‰ç·£/å¾Œç·£æ¯”ä¾‹: ${(v.anteriorHeight / v.posteriorHeight * 100).toFixed(0)}% (> 125%)`
                    });
                }
                if (biconcave) {
                    abnormalities.push({
                        type: 'danger',
                        title: `${v.name} Biconcave Compression`,
                        detail: `ä¸­æ®µé«˜åº¦: ${(v.middleHeight).toFixed(1)} px (< 75% å´é‚Šå¹³å‡)`
                    });
                }
            });

            // 2. Listhesis
            checkListhesis().forEach(l => {
                abnormalities.push({
                    type: 'danger',
                    title: `${l.level} ${l.type}`,
                    detail: `å¾Œç·£åç§»: ${l.shift}%`
                });
            });

            // 3. çµ‚æ¿é‡ç–Š (æ¤é–“ç›¤ç‹¹çª„)
            const ordered = getAnatomicalOrder();
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics || !metrics.overlap) continue;
                abnormalities.push({
                    type: 'warning',
                    title: `${getDiscLevel(ordered[i].name, ordered[i + 1].name)} Disc narrowing`,
                    detail: 'ä¸Šä¸‹çµ‚æ¿æœ‰é‡ç–Š'
                });
            }

            // 4. é«˜åº¦éé€²
            checkHeightProgression().forEach(h => {
                abnormalities.push({ type: 'warning', title: h.level, detail: h.issue });
            });

            if (abnormalities.length === 0) {
                container.innerHTML = '<div style="color: #27ae60; font-size: 12px; padding: 10px;">âœ… æœªæª¢æ¸¬åˆ°æ˜é¡¯ç•°å¸¸</div>';
                return;
            }

            container.innerHTML = abnormalities.map(a => `
                <div class="abnormality-card ${a.type}">
                    <strong>âš ï¸ ${a.title}</strong><br>
                    <span style="font-size: 11px;">${a.detail}</span>
                </div>`).join('');
        }

        // ==================== åŒ¯å‡º ====================
        function exportData() {
            if (vertebrae.length === 0) { alert('è«‹å…ˆå®Œæˆæ¨™è¨»'); return; }

            const ordered = getAnatomicalOrder();

            // è¨ˆç®—æ¤é–“ç›¤
            const discData = [];
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;

                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                const upperLower = getLowerEndplate(ordered[i]);
                const lowerUpper = getUpperEndplate(ordered[i + 1]);

                discData.push({
                    level,
                    upperEndplate: upperLower,
                    lowerEndplate: lowerUpper,
                    anteriorHeight: metrics.anteriorHeight,
                    posteriorHeight: metrics.posteriorHeight,
                    middleHeight: metrics.middleHeight,
                    wedgeAngle: metrics.wedgeAngle,
                    overlap: metrics.overlap
                });
            }

            const data = {
                version: "2.3",
                exportDate: new Date().toISOString(),
                spineType: spineType,
                endplatePointMode: endplatePointMode,
                imageInfo: originalImage ? {
                    width: originalImage.width,
                    height: originalImage.height
                } : null,
                vertebrae: ordered.map(v => {
                    const entry = {
                        name: v.name,
                        boundaryType: v.boundaryType || null,
                        hasMiddlePoints: v.hasMiddlePoints
                    };
                    if (v.boundaryType === 'upper') {
                        entry.points = {
                            anteriorSuperior: v.points[0],
                            middleSuperior: v.points[1],
                            posteriorSuperior: v.points[2]
                        };
                    } else if (v.boundaryType === 'lower') {
                        entry.points = {
                            anteriorInferior: v.points[0],
                            middleInferior: v.points[1],
                            posteriorInferior: v.points[2]
                        };
                    } else {
                        entry.points = {
                            anteriorSuperior: v.points[0],
                            middleSuperior: v.points[1],
                            posteriorSuperior: v.points[2],
                            posteriorInferior: v.points[3],
                            middleInferior: v.points[4],
                            anteriorInferior: v.points[5]
                        };
                        entry.anteriorHeight = v.anteriorHeight;
                        entry.middleHeight = v.middleHeight;
                        entry.posteriorHeight = v.posteriorHeight;
                        const fractureType = checkVertebraAbnormal(v);
                        entry.anteriorWedgingFracture = fractureType === 'anteriorWedging';
                        entry.crushDeformityFracture = fractureType === 'crushDeformity';
                        entry.biconcaveCompressionFracture = checkBiconcaveCompression(v);
                    }
                    return entry;
                }),
                discs: discData,
                abnormalities: {
                    compressionFractures: vertebrae
                        .filter(v => !v.boundaryType && checkVertebraAbnormal(v))
                        .map(v => ({
                            name: v.name,
                            type: checkVertebraAbnormal(v) // 'anteriorWedging' or 'crushDeformity'
                        })),
                    biconcaveCompression: vertebrae
                        .filter(v => !v.boundaryType && checkBiconcaveCompression(v))
                        .map(v => ({
                            name: v.name
                        })),
                    listhesis: checkListhesis(),
                    discOverlap: discData
                        .filter(d => d.overlap)
                        .map(d => d.level),
                    heightProgressionIssues: checkHeightProgression()
                }
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spine_annotation_${spineType}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportReport() {
            if (vertebrae.length === 0) { alert('è«‹å…ˆå®Œæˆæ¨™è¨»'); return; }

            const ordered = getAnatomicalOrder();
            let report = `è„Šæ¤æ¨™è¨»å ±å‘Š\n${'='.repeat(40)}\n\n`;
            report += `è„Šæ¤é¡å‹: ${spineType === 'L' ? 'è…°æ¤' : 'é ¸æ¤'}\n`;
            report += `æ¨™è¨»æ—¥æœŸ: ${new Date().toLocaleString('zh-TW')}\n\n`;

            report += `æ¤é«”åˆ†æ\n${'-'.repeat(30)}\n`;
            ordered.forEach(v => {
                if (v.boundaryType) {
                    report += `${v.name}: é‚Šç•Œæ¤é«” (${v.boundaryType === 'upper' ? 'ä¸Šçµ‚æ¿' : 'ä¸‹çµ‚æ¿'})\n`;
                } else {
                    const abnormal = checkVertebraAbnormal(v);
                    const biconcave = checkBiconcaveCompression(v);
                    report += `${v.name}: å‰ç·£ ${v.anteriorHeight?.toFixed(1)}px / ä¸­é–“ ${v.middleHeight?.toFixed(1)}px / å¾Œç·£ ${v.posteriorHeight?.toFixed(1)}px`;
                    report += ` (å‰/å¾Œ ${(v.anteriorHeight / v.posteriorHeight * 100).toFixed(0)}%)`;
                    if (abnormal === 'anteriorWedging') report += ` âš ï¸ Anterior Wedging Fracture`;
                    if (abnormal === 'crushDeformity') report += ` âš ï¸ Crush Deformity Fracture`;
                    if (biconcave) report += ` âš ï¸ Biconcave Compression`;
                    report += `\n`;
                }
            });

            report += `\næ¤é–“ç›¤åˆ†æ\n${'-'.repeat(30)}\n`;
            for (let i = 0; i < ordered.length - 1; i++) {
                const metrics = calculateDiscMetrics(ordered[i], ordered[i + 1]);
                if (!metrics) continue;
                const level = getDiscLevel(ordered[i].name, ordered[i + 1].name);
                report += `${level}: é«˜åº¦ ${metrics.middleHeight.toFixed(1)}px, Wedge ${metrics.wedgeAngle.toFixed(1)}Â°`;
                if (metrics.overlap) report += ` âš ï¸ çµ‚æ¿é‡ç–Š`;
                report += `\n`;
            }

            const listhesis = checkListhesis();
            if (listhesis.length > 0) {
                report += `\næ»‘è„«æª¢æ¸¬\n${'-'.repeat(30)}\n`;
                listhesis.forEach(l => {
                    report += `${l.level}: ${l.type} (${l.shift}%)\n`;
                });
            }

            navigator.clipboard.writeText(report).then(() => {
                alert('å ±å‘Šå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿');
            });
        }
    </script>
</body>
</html>
