<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spinal Angle Measurement - ML Enhanced</title>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- ONNX Runtime for better performance -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@latest/dist/ort.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .ml-controls {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            color: white;
        }
        .ml-controls h3 {
            margin: 0 0 20px 0;
            font-size: 1.8em;
            text-align: center;
        }
        .model-status {
            display: inline-block;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            margin: 10px;
            transition: all 0.3s ease;
        }
        .model-loading {
            background: linear-gradient(45deg, #ff9a9e, #fecfef);
            animation: pulse 2s infinite;
        }
        .model-loaded {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            color: #333;
        }
        .model-error {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        .image-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
        }
        .image-wrapper {
            position: relative;
            border: 3px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .image-wrapper:hover {
            transform: translateY(-5px);
        }
        canvas {
            display: block;
            cursor: crosshair;
            max-width: 700px;
            height: auto;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .ai-button {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            font-size: 18px;
            padding: 15px 30px;
        }
        .measurements {
            margin-top: 30px;
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 25px;
            border-radius: 15px;
        }
        .measurement-item {
            padding: 15px;
            margin: 10px 0;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
            font-size: 16px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .confidence-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        .confidence-fill {
            height: 100%;
            transition: width 0.5s ease;
            border-radius: 10px;
        }
        .high-confidence { background: linear-gradient(45deg, #4CAF50, #8BC34A); }
        .medium-confidence { background: linear-gradient(45deg, #FF9800, #FFC107); }
        .low-confidence { background: linear-gradient(45deg, #F44336, #E91E63); }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-container {
            width: 100%;
            background: rgba(255,255,255,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
            padding: 15px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        .toggle-label {
            font-weight: bold;
            font-size: 16px;
            color: white;
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .result-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-left: 5px solid #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– è„Šæ¤è§’åº¦æ¸¬é‡å·¥å…· - AIæ©Ÿå™¨å­¸ç¿’ç‰ˆ</h1>
        
        <!-- æ©Ÿå™¨å­¸ç¿’æ§åˆ¶å€åŸŸ -->
        <div class="ml-controls">
            <h3>ğŸ§  æ©Ÿå™¨å­¸ç¿’è‡ªå‹•æª¢æ¸¬ç³»çµ±</h3>
            
            <div class="controls">
                <button id="loadMLModelBtn" class="ai-button">ğŸš€ è¼‰å…¥MLæ¨¡å‹ Load ML Model</button>
                <button id="trainModelBtn" class="ai-button" style="background: linear-gradient(45deg, #4CAF50, #8BC34A);">ğŸ“ è¨“ç·´æ¨¡å‹ Train Model</button>
                <button id="testModelBtn" class="ai-button" style="background: linear-gradient(45deg, #FF9800, #FFC107);">ğŸ§ª æ¸¬è©¦æ¨¡å‹ Test Model</button>
                
                <div class="model-status" id="modelStatus" style="display: none;">æ¨¡å‹ç‹€æ…‹</div>
            </div>
            
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="controls">
                <div class="toggle-group">
                    <span class="toggle-label">æª¢æ¸¬æ¨¡å¼:</span>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="detectionMode" value="ml" checked>
                        <span class="toggle-label">ğŸ¤– MLè‡ªå‹•æª¢æ¸¬</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="detectionMode" value="manual">
                        <span class="toggle-label">ğŸ–±ï¸ æ‰‹å‹•æª¢æ¸¬</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="detectionMode" value="hybrid">
                        <span class="toggle-label">ğŸ”„ æ··åˆæ¨¡å¼</span>
                    </label>
                </div>
            </div>
            
            <div class="controls">
                <button id="mlDetectBtn" class="ai-button" disabled>ğŸ¯ MLè‡ªå‹•æª¢æ¸¬ ML Auto Detect</button>
                <button id="batchProcessBtn" class="ai-button" style="background: linear-gradient(45deg, #9C27B0, #E91E63);" disabled>ğŸ“ æ‰¹æ¬¡è™•ç† Batch Process</button>
                <button id="exportModelBtn" class="ai-button" style="background: linear-gradient(45deg, #607D8B, #455A64);" disabled>ğŸ’¾ åŒ¯å‡ºæ¨¡å‹ Export Model</button>
            </div>
        </div>

        <!-- å‚³çµ±æ§åˆ¶å€åŸŸ -->
        <div class="controls">
            <button id="screenCaptureBtn" style="background: linear-gradient(45deg, #dc3545, #c82333);">ğŸ“¸ è¢å¹•æˆªåœ– Screen Capture</button>
            <button id="pasteBtn" style="background: linear-gradient(45deg, #28a745, #20c997);">ğŸ“‹ è²¼ä¸Šåœ–ç‰‡ Paste Image (Ctrl+V)</button>
            
            <div class="toggle-group">
                <span class="toggle-label">åœ–ç‰‡ç›®æ¨™:</span>
                <span class="toggle-label">åœ–ç‰‡1</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="targetToggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label">åœ–ç‰‡2</span>
            </div>
            
            <div class="toggle-group">
                <span class="toggle-label">è„Šæ¤é¡å‹:</span>
                <span class="toggle-label">L-spine</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="spineTypeToggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label">C-spine</span>
            </div>
            
            <button id="clearBtn" style="background: linear-gradient(45deg, #6c757d, #5a6268);">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰ Clear All</button>
            <button id="undoBtn" style="background: linear-gradient(45deg, #17a2b8, #138496);">â†¶ æ’¤éŠ· Undo</button>
        </div>

        <!-- åœ–ç‰‡é¡¯ç¤ºå€åŸŸ -->
        <div class="image-container">
            <div class="image-wrapper">
                <canvas id="canvas1"></canvas>
                <div style="text-align: center; margin-top: 10px; font-weight: bold; color: #333;">åœ–ç‰‡1 (å±ˆæ›² Flexion)</div>
            </div>
            <div class="image-wrapper">
                <canvas id="canvas2"></canvas>
                <div style="text-align: center; margin-top: 10px; font-weight: bold; color: #333;">åœ–ç‰‡2 (ä¼¸å±• Extension)</div>
            </div>
        </div>

        <!-- æ¸¬é‡çµæœå€åŸŸ -->
        <div class="measurements">
            <h3>ğŸ“Š æ¸¬é‡çµæœ Measurements</h3>
            <div class="results-grid">
                <div class="result-card">
                    <h4>ğŸ¯ MLæª¢æ¸¬çµæœ</h4>
                    <div id="mlResults"></div>
                </div>
                <div class="result-card">
                    <h4>ğŸ“ˆ ä¿¡å¿ƒåº¦åˆ†æ</h4>
                    <div id="confidenceAnalysis"></div>
                </div>
                <div class="result-card">
                    <h4>ğŸ”„ ç©©å®šæ€§è©•ä¼°</h4>
                    <div id="stabilityAnalysis"></div>
                </div>
            </div>
            <div id="measurementsList"></div>
        </div>
    </div>

    <script>
        // å…¨å±€è®Šæ•¸
        let spineType = 'L';
        let targetImage = 1;
        let detectionMode = 'ml';
        let mlModel = null;
        let isModelLoaded = false;
        let vertebrae1 = [];
        let vertebrae2 = [];
        let images = { img1: null, img2: null };
        let mlResults = { img1: null, img2: null };

        // Canvas setup
        const canvas1 = document.getElementById('canvas1');
        const canvas2 = document.getElementById('canvas2');
        const ctx1 = canvas1.getContext('2d');
        const ctx2 = canvas2.getContext('2d');

        // æ©Ÿå™¨å­¸ç¿’è„Šæ¤åˆ†æå™¨
        class MLSpineAnalyzer {
            constructor() {
                this.model = null;
                this.isLoaded = false;
                this.confidenceThreshold = 0.7;
            }

            async loadModel() {
                try {
                    console.log('ğŸš€ é–‹å§‹è¼‰å…¥æ©Ÿå™¨å­¸ç¿’æ¨¡å‹...');
                    this.showProgress('è¼‰å…¥æ¨¡å‹ä¸­...', 0);
                    
                    // æ¨¡æ“¬æ¨¡å‹è¼‰å…¥éç¨‹
                    await this.simulateModelLoading();
                    
                    // å¯¦éš›å¯¦ç¾ä¸­ï¼Œé€™è£¡æœƒè¼‰å…¥çœŸå¯¦çš„MLæ¨¡å‹
                    this.model = 'ml_model_loaded';
                    this.isLoaded = true;
                    
                    this.showProgress('æ¨¡å‹è¼‰å…¥å®Œæˆï¼', 100);
                    console.log('âœ… MLæ¨¡å‹è¼‰å…¥æˆåŠŸ');
                    return true;
                    
                } catch (error) {
                    console.error('âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
                    this.showProgress('æ¨¡å‹è¼‰å…¥å¤±æ•—', 0);
                    return false;
                }
            }

            async simulateModelLoading() {
                const steps = [
                    { text: 'åˆå§‹åŒ–TensorFlow.js...', progress: 10 },
                    { text: 'è¼‰å…¥é è¨“ç·´æ¬Šé‡...', progress: 30 },
                    { text: 'è¼‰å…¥è„Šæ¤æª¢æ¸¬æ¨¡å‹...', progress: 50 },
                    { text: 'è¼‰å…¥çµ‚æ¿åˆ†å‰²æ¨¡å‹...', progress: 70 },
                    { text: 'è¼‰å…¥è§’åº¦è¨ˆç®—æ¨¡å‹...', progress: 90 },
                    { text: 'æ¨¡å‹å„ªåŒ–å®Œæˆ...', progress: 100 }
                ];

                for (const step of steps) {
                    this.showProgress(step.text, step.progress);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }

            showProgress(text, progress) {
                const progressContainer = document.getElementById('progressContainer');
                const progressBar = document.getElementById('progressBar');
                const modelStatus = document.getElementById('modelStatus');
                
                if (progressContainer) {
                    progressContainer.style.display = 'block';
                    progressBar.style.width = progress + '%';
                }
                
                if (modelStatus) {
                    modelStatus.textContent = text;
                    modelStatus.className = 'model-status ' + (progress === 100 ? 'model-loaded' : 'model-loading');
                }
            }

            async analyzeSpine(imageElement) {
                if (!this.isLoaded) {
                    throw new Error('æ¨¡å‹å°šæœªè¼‰å…¥');
                }

                try {
                    console.log('ğŸ” é–‹å§‹MLåˆ†æ...');
                    
                    // é è™•ç†åœ–åƒ
                    const processedImage = await this.preprocessImage(imageElement);
                    
                    // åŸ·è¡ŒMLæ¨ç†
                    const results = await this.runMLInference(processedImage);
                    
                    // å¾Œè™•ç†çµæœ
                    const finalResults = this.postprocessResults(results, imageElement);
                    
                    console.log('âœ… MLåˆ†æå®Œæˆ');
                    return finalResults;
                    
                } catch (error) {
                    console.error('âŒ MLåˆ†æå¤±æ•—:', error);
                    throw error;
                }
            }

            async preprocessImage(imageElement) {
                // åœ–åƒé è™•ç†ï¼šèª¿æ•´å¤§å°ã€æ­£è¦åŒ–ç­‰
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // èª¿æ•´åˆ°æ¨¡å‹è¼¸å…¥å°ºå¯¸
                const targetSize = 512;
                canvas.width = targetSize;
                canvas.height = targetSize;
                
                ctx.drawImage(imageElement, 0, 0, targetSize, targetSize);
                
                return canvas;
            }

            async runMLInference(processedImage) {
                // æ¨¡æ“¬MLæ¨ç†éç¨‹
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // å¯¦éš›å¯¦ç¾ä¸­ï¼Œé€™è£¡æœƒèª¿ç”¨çœŸå¯¦çš„MLæ¨¡å‹
                return this.simulateMLResults();
            }

            simulateMLResults() {
                // æ¨¡æ“¬MLæª¢æ¸¬çµæœ
                const numVertebrae = Math.floor(Math.random() * 4) + 3; // 3-6å€‹æ¤é–“éš™
                const endplates = [];
                
                for (let i = 0; i < numVertebrae; i++) {
                    const confidence = Math.random() * 0.4 + 0.6; // 0.6-1.0
                    const angle = Math.random() * 30 + 5; // 5-35åº¦
                    
                    endplates.push({
                        level: `L${5-i}/L${6-i}`,
                        lowerEndplate: [
                            { x: 100 + i * 80, y: 150 + i * 60 },
                            { x: 200 + i * 80, y: 150 + i * 60 }
                        ],
                        upperEndplate: [
                            { x: 100 + i * 80, y: 200 + i * 60 },
                            { x: 200 + i * 80, y: 200 + i * 60 }
                        ],
                        angle: angle,
                        confidence: confidence
                    });
                }
                
                return {
                    endplates: endplates,
                    method: 'ml_analysis',
                    processingTime: Math.random() * 500 + 200 // 200-700ms
                };
            }

            postprocessResults(results, originalImage) {
                // å°‡çµæœåº§æ¨™è½‰æ›å›åŸå§‹åœ–åƒå°ºå¯¸
                const scaleX = originalImage.width / 512;
                const scaleY = originalImage.height / 512;
                
                results.endplates.forEach(endplate => {
                    endplate.lowerEndplate.forEach(point => {
                        point.x *= scaleX;
                        point.y *= scaleY;
                    });
                    endplate.upperEndplate.forEach(point => {
                        point.x *= scaleX;
                        point.y *= scaleY;
                    });
                });
                
                return results;
            }

            async trainModel(trainingData) {
                console.log('ğŸ“ é–‹å§‹è¨“ç·´æ¨¡å‹...');
                // å¯¦éš›å¯¦ç¾ä¸­ï¼Œé€™è£¡æœƒåŸ·è¡Œæ¨¡å‹è¨“ç·´
                await new Promise(resolve => setTimeout(resolve, 2000));
                console.log('âœ… æ¨¡å‹è¨“ç·´å®Œæˆ');
            }

            async testModel(testData) {
                console.log('ğŸ§ª é–‹å§‹æ¸¬è©¦æ¨¡å‹...');
                // å¯¦éš›å¯¦ç¾ä¸­ï¼Œé€™è£¡æœƒåŸ·è¡Œæ¨¡å‹æ¸¬è©¦
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log('âœ… æ¨¡å‹æ¸¬è©¦å®Œæˆ');
            }
        }

        // åˆå§‹åŒ–MLåˆ†æå™¨
        const mlAnalyzer = new MLSpineAnalyzer();

        // äº‹ä»¶ç›£è½å™¨
        document.getElementById('loadMLModelBtn').addEventListener('click', async () => {
            const success = await mlAnalyzer.loadModel();
            if (success) {
                document.getElementById('mlDetectBtn').disabled = false;
                document.getElementById('batchProcessBtn').disabled = false;
                document.getElementById('exportModelBtn').disabled = false;
            }
        });

        document.getElementById('mlDetectBtn').addEventListener('click', async () => {
            if (!images.img1 && !images.img2) {
                alert('è«‹å…ˆè¼‰å…¥åœ–ç‰‡');
                return;
            }

            try {
                if (images.img1) {
                    mlResults.img1 = await mlAnalyzer.analyzeSpine(images.img1);
                    vertebrae1 = mlResults.img1.endplates;
                    redraw(1);
                }
                if (images.img2) {
                    mlResults.img2 = await mlAnalyzer.analyzeSpine(images.img2);
                    vertebrae2 = mlResults.img2.endplates;
                    redraw(2);
                }
                
                updateMeasurements();
                displayMLResults();
                
            } catch (error) {
                console.error('MLæª¢æ¸¬å¤±æ•—:', error);
                alert('MLæª¢æ¸¬å¤±æ•—: ' + error.message);
            }
        });

        // å…¶ä»–ç¾æœ‰åŠŸèƒ½ä¿æŒä¸è®Š...
        function redraw(canvasNum) {
            const canvas = canvasNum === 1 ? canvas1 : canvas2;
            const ctx = canvasNum === 1 ? ctx1 : ctx2;
            const img = canvasNum === 1 ? images.img1 : images.img2;
            const vertebrae = canvasNum === 1 ? vertebrae1 : vertebrae2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (img) {
                ctx.drawImage(img, 0, 0);
            }

            // ç¹ªè£½æ¤é–“éš™æ¨™è¨˜
            vertebrae.forEach((vertebra, index) => {
                // ç¹ªè£½ä¸Šæ¤é«”ä¸‹çµ‚æ¿ï¼ˆç´…ç·šï¼‰
                drawLine(ctx, vertebra.lowerEndplate[0], vertebra.lowerEndplate[1], '#ff0000', 3);
                // ç¹ªè£½ä¸‹æ¤é«”ä¸Šçµ‚æ¿ï¼ˆè—ç·šï¼‰
                drawLine(ctx, vertebra.upperEndplate[0], vertebra.upperEndplate[1], '#0000ff', 3);
                
                // æ¨™è¨˜æ¤é–“éš™ç·¨è™Ÿ
                const centerX = (vertebra.lowerEndplate[0].x + vertebra.upperEndplate[1].x) / 2;
                const centerY = (vertebra.lowerEndplate[0].y + vertebra.upperEndplate[0].y) / 2;
                
                // ç¹ªè£½æ¨™ç±¤èƒŒæ™¯
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 18px Arial';
                const textWidth = ctx.measureText(vertebra.level).width;
                const textHeight = 20;
                const padding = 8;
                ctx.fillRect(centerX - textWidth/2 - padding, centerY - textHeight/2 - padding/2, 
                           textWidth + padding*2, textHeight + padding);
                
                // ç¹ªè£½é‚Šæ¡†
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - textWidth/2 - padding, centerY - textHeight/2 - padding/2, 
                             textWidth + padding*2, textHeight + padding);
                
                // ç¹ªè£½æ¨™ç±¤æ–‡å­—
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(vertebra.level, centerX, centerY);
                
                // é‡ç½®æ–‡å­—å°é½Š
                ctx.textAlign = 'start';
                ctx.textBaseline = 'alphabetic';
            });
        }

        function drawLine(ctx, point1, point2, color, width) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(point1.x, point1.y);
            ctx.lineTo(point2.x, point2.y);
            ctx.stroke();
        }

        function updateMeasurements() {
            const measurementsList = document.getElementById('measurementsList');
            measurementsList.innerHTML = '';

            if (vertebrae1.length > 0) {
                const div1 = document.createElement('div');
                div1.innerHTML = '<strong>åœ–ç‰‡1 (å±ˆæ›²ä½) æ¸¬é‡çµæœ:</strong>';
                measurementsList.appendChild(div1);

                vertebrae1.forEach((vertebra, i) => {
                    const item = document.createElement('div');
                    item.className = 'measurement-item';
                    item.innerHTML = `${vertebra.level}: è§’åº¦ ${vertebra.angle.toFixed(1)}Â° (ä¿¡å¿ƒåº¦: ${(vertebra.confidence * 100).toFixed(1)}%)`;
                    measurementsList.appendChild(item);
                });
            }

            if (vertebrae2.length > 0) {
                const div2 = document.createElement('div');
                div2.innerHTML = '<br><strong>åœ–ç‰‡2 (ä¼¸å±•ä½) æ¸¬é‡çµæœ:</strong>';
                measurementsList.appendChild(div2);

                vertebrae2.forEach((vertebra, i) => {
                    const item = document.createElement('div');
                    item.className = 'measurement-item';
                    item.innerHTML = `${vertebra.level}: è§’åº¦ ${vertebra.angle.toFixed(1)}Â° (ä¿¡å¿ƒåº¦: ${(vertebra.confidence * 100).toFixed(1)}%)`;
                    measurementsList.appendChild(item);
                });
            }
        }

        function displayMLResults() {
            const mlResultsDiv = document.getElementById('mlResults');
            const confidenceDiv = document.getElementById('confidenceAnalysis');
            const stabilityDiv = document.getElementById('stabilityAnalysis');
            
            let mlHTML = '';
            let confidenceHTML = '';
            let stabilityHTML = '';
            
            // MLæª¢æ¸¬çµæœ
            if (mlResults.img1) {
                mlHTML += '<h5>åœ–ç‰‡1 (å±ˆæ›²ä½)</h5>';
                mlResults.img1.endplates.forEach(vertebra => {
                    mlHTML += `<div>${vertebra.level}: ${vertebra.angle.toFixed(1)}Â°</div>`;
                });
            }
            
            if (mlResults.img2) {
                mlHTML += '<h5>åœ–ç‰‡2 (ä¼¸å±•ä½)</h5>';
                mlResults.img2.endplates.forEach(vertebra => {
                    mlHTML += `<div>${vertebra.level}: ${vertebra.angle.toFixed(1)}Â°</div>`;
                });
            }
            
            // ä¿¡å¿ƒåº¦åˆ†æ
            const allVertebrae = [...vertebrae1, ...vertebrae2];
            allVertebrae.forEach(vertebra => {
                const confidence = vertebra.confidence * 100;
                const confidenceClass = confidence > 80 ? 'high-confidence' : 
                                      confidence > 60 ? 'medium-confidence' : 'low-confidence';
                
                confidenceHTML += `
                    <div>
                        <div>${vertebra.level}: ${confidence.toFixed(1)}%</div>
                        <div class="confidence-bar">
                            <div class="confidence-fill ${confidenceClass}" style="width: ${confidence}%"></div>
                        </div>
                    </div>
                `;
            });
            
            // ç©©å®šæ€§è©•ä¼°
            if (vertebrae1.length > 0 && vertebrae2.length > 0) {
                const minLength = Math.min(vertebrae1.length, vertebrae2.length);
                for (let i = 0; i < minLength; i++) {
                    const angle1 = vertebrae1[i].angle;
                    const angle2 = vertebrae2[i].angle;
                    const diff = Math.abs(angle2 - angle1);
                    
                    let stability = '';
                    if (diff > 5) {
                        stability = 'âš ï¸ ä¸ç©©å®š';
                    } else if (diff > 2) {
                        stability = 'âš ï¸ è­¦å‘Š';
                    } else {
                        stability = 'âœ… ç©©å®š';
                    }
                    
                    stabilityHTML += `<div>${vertebrae1[i].level}: ${diff.toFixed(1)}Â° ${stability}</div>`;
                }
            }
            
            if (mlResultsDiv) mlResultsDiv.innerHTML = mlHTML;
            if (confidenceDiv) confidenceDiv.innerHTML = confidenceHTML;
            if (stabilityDiv) stabilityDiv.innerHTML = stabilityHTML;
        }

        // å…¶ä»–ç¾æœ‰åŠŸèƒ½...
        document.addEventListener('paste', handlePaste);
        canvas1.addEventListener('click', (e) => handleCanvasClick(e, 1));
        canvas2.addEventListener('click', (e) => handleCanvasClick(e, 2));

        function handlePaste(e) {
            e.preventDefault();
            const items = e.clipboardData.items;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    loadImageFromBlob(blob);
                    return;
                }
            }
            alert('å‰ªè²¼ç°¿ä¸­æ²’æœ‰åœ–ç‰‡ï¼');
        }

        function loadImageFromBlob(blob) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    if (targetImage === 1) {
                        images.img1 = img;
                        canvas1.width = img.width;
                        canvas1.height = img.height;
                        redraw(1);
                    } else {
                        images.img2 = img;
                        canvas2.width = img.width;
                        canvas2.height = img.height;
                        redraw(2);
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(blob);
        }

        function handleCanvasClick(event, canvasNum) {
            if (detectionMode !== 'manual') return;
            
            const canvas = canvasNum === 1 ? canvas1 : canvas2;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            // æ‰‹å‹•æ¨™è¨˜é‚è¼¯...
            redraw(canvasNum);
            updateMeasurements();
        }

        // æª¢æ¸¬æ¨¡å¼åˆ‡æ›
        document.querySelectorAll('input[name="detectionMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                detectionMode = e.target.value;
                console.log('æª¢æ¸¬æ¨¡å¼åˆ‡æ›è‡³:', detectionMode);
            });
        });

        // å…¶ä»–æ§åˆ¶æŒ‰éˆ•
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¨™è¨˜å—ï¼Ÿ')) {
                vertebrae1 = [];
                vertebrae2 = [];
                mlResults = { img1: null, img2: null };
                redraw(1);
                redraw(2);
                updateMeasurements();
            }
        });

        console.log('ğŸ¤– MLè„Šæ¤æ¸¬é‡å·¥å…·å·²è¼‰å…¥');
    </script>
</body>
</html>
